#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: guess_encoding,v 1.7 2010/05/07 19:38:36 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2007,2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Which are the expected Unicode codepoints?
my @expected_codepoints = (9, 10, 13, # newlines+tab
			   32..127,
			   #(map { ord } split //, "äöüÄÖÜß"),
			   #0x20ac, # euro sign
			   #0x3040..0x309f, # hiragana
			   #0x30a0..0x30ff, # katakana
			   #0x3400..0x4DB5, # CJK Unified Ideographs Extension A
			   #0x4E00..0x9fc3, # CJK Unified Ideographs
			   0x0590..0x5ff, # hebrew
			  );

# Which are the expected encodings? May be empty, in this case
# all to perl available encodings will be checked.
#my @expected_encodings = qw(cp1252 iso-8859-1 utf-8 iso-8859-15);
my @expected_encodings = qw();

# Text to analyze, specify in raw octets:
#my $octets_to_analyze = "Bla äöü \x80";		# cp1252 sample
#my $octets_to_analyze = "Bla Ã¤Ã¶Ã¼ â\202¬";		# utf-8 sample
#my $octets_to_analyze = "Bla äöü ¤";			# iso-8859-15 sample
my $octets_to_analyze = "\xf0\xe5\xe1\xee\xe1\xf8";
# Or read from a file:
#my $octets_to_analyze = do { open my $fh, shift or die "Cannot open file (please specify on cmdline): $!"; local $/; <$fh> };

######################################################################
# No user-servicable parts below this point.

use strict;
use Encode;

if (!@expected_encodings) {
    @expected_encodings = Encode->encodings(":all");
}
my %expected_codepoints = map {($_,1)} @expected_codepoints;
my @encoding_result;

for my $encoding (@expected_encodings) {
    my $characters = eval {
	decode($encoding, $octets_to_analyze, Encode::FB_CROAK|Encode::LEAVE_SRC);
    };
    if (!$@) {
	my %got_codepoints;
	for my $codepoint (map { ord } split //, $characters) {
	    $got_codepoints{$codepoint}++;
	}
	my $fitting_codepoints = 0;
	while(my($k,$v) = each %got_codepoints) {
	    if (exists $expected_codepoints{$k}) {
		$fitting_codepoints++;
	    }
	}
	if (keys %got_codepoints) {
	    push @encoding_result, [$encoding, $fitting_codepoints*100/keys %got_codepoints];
	}
    }
}

@encoding_result = sort { $b->[1] <=> $a->[1] } @encoding_result;
for my $result (@encoding_result) {
    printf "%-30s: %4.1f%%\n", $result->[0], $result->[1];
}

__END__
