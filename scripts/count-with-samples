#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2014,2015,2017 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use Getopt::Long;

sub usage () {
    die <<EOF;
usage: $0 [--auto-shorten-samples] [--no-crop-samples] [--reverse | --rx regexp | --md5sum | --md5]

Please feed input via standard input.
EOF
}

my $auto_shorten_samples;
my $do_reverse;
my $parse;
my $rx;
my $crop_samples = 1;

sub check_dup_parse_option_error ($) {
    die "Multiple parse options (--$parse, --$_[0]) specified.\n"
	if $parse;
}

GetOptions(
	   "auto-shorten-samples" => \$auto_shorten_samples,
	   'crop-samples!' => \$crop_samples,
	   "r|reverse" => \$do_reverse,
	   "rx=s" => \$rx,
	   'md5sum' => sub { check_dup_parse_option_error $_[0]; $parse = 'md5sum' },
	   'md5'    => sub { check_dup_parse_option_error $_[0]; $parse = 'md5'    },
	  )
    or usage;
@ARGV and usage;

my $rx_qr;
if ($rx) {
    $rx_qr = qr{$rx};
}

my $terminal_width;
{
    if (eval { require Term::ReadKey; 1 }) {
	($terminal_width) = Term::ReadKey::GetTerminalSize();
    }
    if (!$terminal_width) {
        $terminal_width = 80;
    }
}

my %count;
my %count_samples;
while(<>) {
    chomp;
    my($k, $v);
    if ($rx_qr) {
	if ($_ =~ $rx_qr) {
	    ($k, $v) = ($+{k}, $+{v});
	} else {
	    warn "Ignore line <$_> while matching against /$rx/...\n";
	    next;
	}
    } elsif ($parse eq 'md5sum') {
	if (!(($k, $v) = $_ =~ m{^(\S+)\s+(.*)})) {
	    warn "Cannot parse <$_> as a md5sum line\n";
	}
    } elsif ($parse eq 'md5') {
	if (!(($v, $k) = $_ =~ m{^MD5 \(([^)]+)\) = (.*)})) {
	    warn "Cannot parse <$_> as a md5 line\n";
	}
    } elsif (my($first, $second) = $_ =~ m{^([^:]+):\s*(.*)}) {
	($k, $v) = ($first, $second);
	if ($do_reverse) { ($k, $v) = ($v, $k) }
    } else {
	warn "Ignore line <$_>\n";
    }

    if (!defined $k || !defined $v) {
	warn "Cannot parse/find key and/or value, ignore line <$_>...\n";
	next;
    }

    $count{$k}++;
    $count_samples{$k}->{$v}++;
}

for my $row (sort { $count{$b} <=> $count{$a} } keys %count) {
    printf "%7d ", $count{$row};
    my $term_col = 8;
    print $row;
    $term_col += length($row);
    my $this_count_samples = $count_samples{$row};
    my $need_comma = 0;
    my $need_open = 1;
    my @samples = sort {
	my $res = $this_count_samples->{$b} <=> $this_count_samples->{$a};
	if ($res == 0) {
	    $a cmp $b;
	} else {
	    $res;
	}
    } keys %$this_count_samples;
    if ($auto_shorten_samples) {
	die "NYI"; # XXX
    }
    for my $sample_i (0 .. $#samples) {
	my $sample = $samples[$sample_i];
	$term_col += 2 if $need_open;
	$term_col += 2 if $need_comma;
	$term_col += length $sample;
	if ($crop_samples && $sample_i > 0 && $term_col >= $terminal_width - 4) { # place for "...)"
	    if ($sample_i <= $#samples) {
		print "...";
	    }
	    last;
	}
	print " (" if $need_open; $need_open = 0;
	print ", " if $need_comma;
	print $sample;
	$need_comma = 1;
    }
    print ")\n";
}

__END__

=head1 NAME

count-with-samples

=head1 SYNOPSIS

    cat something | count-with-samples [--auto-shorten-samples] [--no-crop-samples] [--reverse | --rx regexp | --md5sum | --md5]

=head1 DESCRIPTION

Do a count on the input data, which should be in the form of

    location: data

where I<location> is something like a file name or so, and I<data> is
the data to be counted (but see the L</--rx> option for arbitrary
matching of input data). A list of location samples is printed along
the data counts.

Not yet implemented: With C<--auto-shorten-samples> the common prefix
of the location samples is determined, and the samples are shortened
by removing this prefix.

Normally the list of samples is cropped to have place in one line.
With C<--no-crop-samples> the list is not cropped.

With C<--reverse> the logic is reversed: counting is done by
I<location>.

For data generated by the linux L<md5sum(1)> tool the option
C<--md5sum> have to be set.

For data generated by the BSD L<md5(1)> tool the option C<--md5> have to be set.

The C<--rx> option lets you define an arbitrary regexp for matching
the key and value field. The regexp should define two named capture
groups: 'k' for the key and 'v' for the value. Example (assume
space-separated fields, first contains the key, second the value):

    cat input_data | count-with-samples -rx '(?<k>\S+)\s+(?<v>.*)'

=head1 EXAMPLES

Group files by their md5 checksums (BSD variant):

    md5 * | count-with-samples -rx 'MD5 \((?<v>[^)]+)\) = (?<k>.*)'

(But actually you would use simple the C<--md5> option instead)

=head1 AUTHOR

Slaven Rezic

=cut
