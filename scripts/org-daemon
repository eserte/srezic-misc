#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: org-daemon,v 1.9 2009/02/13 13:57:13 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;

use Getopt::Long;
use Time::Local qw(timelocal);
use Tk qw(tkinit Ev MainLoop);

{
    package Emacs::Org::Daemon::Date;
    sub new { my $class = shift; bless {@_}, $class }
    sub id { shift->{text} }
}

my $debug;
GetOptions("d|debug!" => \$debug)
    or die "$0 [-debug] orgfile ...";

my %open_warning;
my %org_files;
my %alarmed;
my @lb_contents;
{
    my @org_files = @ARGV;
    if (!@org_files) {
	die "No org files given, exiting...\n";
    }
    %org_files = map { ($_, {}) } @org_files;
}

my $mw = tkinit;
$mw->iconify if !$debug;
my $lb = $mw->Scrolled("Listbox",
		       -width => 60,
		       -height => 6,
		       -scrollbars => "osoe",
		      )->pack(qw(-fill both -expand 1));
$lb->bind("<Double-1>" => sub {
	      show_date_by_index_in_emacs(shift->xyIndex);
	  });

tk_do_one_iteration();
if ($debug) {
    $lb->repeat(3*1000, sub { tk_do_one_iteration() });
} else {
    # synchronize with full minute
    my(@l) = localtime;
    my $first_delay = 60 - $l[0];
    if ($first_delay) {
	$lb->after($first_delay*1000, sub {
		       tk_do_one_iteration();
		       $lb->repeat(60*1000, sub { tk_do_one_iteration() });
		   });
    } else {
	$lb->repeat(60*1000, sub { tk_do_one_iteration() });
    }
}

#$mw->WidgetDump;
MainLoop;

sub show_date_by_index_in_emacs {
    my($index) = @_;
    my $date = $lb_contents[$index];
    die "No date at index $index" if !$date;
    show_date_in_emacs($date);
}

sub show_date_in_emacs {
    my $date = shift;
    my $file = $date->{file};
    die "No file associated with given date" if !defined $file;
    my @cmd = ('emacsclient', '-n',
	       (defined $date->{line} ? '+'.$date->{line} : ()),
	       $file,
	      );
    system @cmd;
}

sub tk_do_one_iteration {
    if (check_for_updates()) {
	update_lb();
    }

    if (check_for_alarms()) {
	update_lb();
    }

    colorize_entries();
}

sub update_lb {
    $lb->delete(0, "end");
    @lb_contents = ();
    my @dates = map { @{ $_->{dates} } } values %org_files;
    @dates = grep { !$alarmed{$_->id} } sort { $a->{epoch} <=> $b->{epoch} } @dates;
    if (!@dates) {
	$lb->insert("end", "<no dates>");
    } else {
	for my $date (@dates) {
	    $lb->insert("end", $date->{text});
	    push @lb_contents, $date;
	}
    }
}

sub colorize_entries {
    for my $i (0 .. $#lb_contents) {
	my $duration = $lb_contents[$i]->{epoch} - time;
	my($fg, $bg) = ('black', 'green');
	if ($duration < 3600) {
	    ($fg, $bg) = ('white', 'red');
	} elsif ($duration < 86400) {
	    ($fg, $bg) = ('black', 'orange');
	} elsif ($duration < 86400*7) {
	    ($fg, $bg) = ('black', 'yellow');
	}
	$lb->itemconfigure($i, -foreground => $fg, -background => $bg);
    }
}

sub check_for_alarms {
    my $changes = 0;
    my %seen;
    my @dates = map { @{ $_->{dates} } } values %org_files;
    my $date_i = -1;
    for my $date (@dates) {
	$date_i++;
	$seen{$date->id}++;
	if ($date->{epoch} <= time && !$alarmed{$date->id}) {
	    my %colargs    = (-background => 'red', -foreground => 'white');
	    my %smlbtnargs = (-font => 'sans 8');
	    my $t = $mw->Toplevel(-title => "Alarm!", %colargs);
	    $t->Label(-text => $date->{text}, # . "\n" . $date->{date} . " " . $date->{time},
		      -justify => 'left',
		      -font => 'sans 24',
		      %colargs,
		     )->pack(qw(-fill x -expand 1));
	    my $overflow = "+00:00";
	    $t->Label(-textvariable => \$overflow,
		      -justify => 'right',
		      -anchor => 'e',
		      %colargs, %smlbtnargs,
		     )->pack(qw(-side right));
	    $t->Button(-text => 'Edit',
		       -command => sub { show_date_in_emacs($date) },
		       -anchor => 'w',
		       -borderwidth => 1,
		       -highlightthickness => 0,
		       -padx => 1, -pady => 1,
		       %colargs, %smlbtnargs,
		      )->pack(qw(-side left));
	    $t->repeat(1000, sub {
			   my $diff = time - $date->{epoch};
			   $overflow = sprintf "+%02d:%02d", int($diff/60), $diff%60;
		       });

	    $Tk::platform = $Tk::platform; # peacify -w
	    if ($Tk::platform eq 'unix') {
		my($wrapper) = $t->wrapper;
		# set sticky flag for gnome and fvwm2
		eval q{
		    $t->property('set','_WIN_STATE','CARDINAL',32,[1],$wrapper); # sticky
		    $t->property('set','_WIN_LAYER','CARDINAL',32,[6],$wrapper); # ontop
		};
		warn $@ if $@;
	    }

	    eval { $t->attributes(-topmost => 1) };
	    warn $@ if $@;

	    $alarmed{$date->id} = 1;
	    $changes++;
	}
    }

    # cleanup all dates
    for my $id (keys %alarmed) {
	if (!$seen{$id}) {
	    delete $alarmed{$id};
	}
    }

    $changes;
}

sub check_for_updates {
    my $changes = 0;
    for my $org_file (keys %org_files) {
	my $org_data = $org_files{$org_file};
	my($modtime) = (stat($org_file))[9];
	if (!defined $modtime) {
	    # non-existing file
	    $org_data->{modified} = $modtime;
	    $org_data->{dates} = [];
	    open_warning($org_file);
	    $changes++;
	    next;
	}
	delete $open_warning{$org_file};
	if (!$org_data->{modified} || $org_data->{modified} < $modtime) {
	    $org_data->{dates} = [ find_dates_in_org_file($org_file) ];
	    $org_data->{modified} = $modtime;
	    $changes++;
	}
    }
    $changes;
}

sub find_dates_in_org_file {
    my($file) = @_;

    my @dates;

    # This is org-stamp-time-of-day-regexp constant from org.el,
    # version 4.67d

    # In newer org.el this seems to have an different format;
    # see org-time-stamp-formats

    # Additionaly the weekday is optional, some org-mode versions seem
    # to deal without the weekday.

    my $org_stamp_time_of_day_regexp = qr{
					     <
					     ([0-9]{4}-[0-9]{2}-[0-9]{2}[ ]+(?:\w+[ ]+)?)
					     ([012][0-9]:[0-5][0-9])>
					     (--?
						 <\1([012][0-9]:[0-5][0-9])>
					     )?
				     }x;

    open my $fh, $file
	or do {
	    open_warning($file);
	    return;
	};
    delete $open_warning{$file};

    while(defined(my $text = <$fh>)) {
	chomp $text;
	if ($text =~ m{-\*-.*\bcoding:\s*([^;]+);.*-\*-}) {
	    my $encoding = $1;
	    binmode $fh, ':encoding(' . $encoding . ')';
	}

	while ($text =~ m{$org_stamp_time_of_day_regexp}g) {
	    my($date, $time) = ($1, $2);
	    my($Y,$M,$D) = $date =~ m{^(\d{4})-(\d{2})-(\d{2})};
	    my($h,$m) = $time =~ m{^(\d{1,2}):(\d{2})};
	    my $epoch = timelocal(0,$m,$h,$D,$M-1,$Y);
	    if ($epoch >= time) {
		push @dates, Emacs::Org::Daemon::Date->new(epoch => $epoch,
							   date  => $date,
							   time  => $time,
							   text  => $text,
							   file  => $file,
							   line  => $.,
							  );
	    }
	}
    }

    @dates;
}

sub open_warning {
    my $file = shift;
    $open_warning{$file} ||= 0;
    if ($open_warning{$file} > 3) {
    } elsif ($open_warning{$file} == 3) {
	warn "Can't open $file: $!. Won't warn anymore!\n";
    } else {
	warn "Can't open $file: $!";
    }
    $open_warning{$file}++;
}

__END__

=head1 NAME

org-daemon - watch for appointments in org-mode files

=head1 SYNOPSIS

    org-daemon orgfile ... &

=head1 DESCRIPTION

B<org-daemon> is a Perl/Tk program which watches one or more emacs
org-mode files for appointments, that is, entries in the form of C<<
<YYYY-MM-DD AAA HH:MM> >> and fires alarms.

=head2 FEATURES

=over

=item * Watch all given files periodically every minute (or in
C<-debug> mode every three seconds)

=item * By double-clicking on an entry, shows the corresponding entry
in emacs itself (needs B<emacsclient> and emacs has to be put into
C<server-start> mode)

=item * Iconified main window shows the list of next appointments,
with entries in different colors (red for appointments in near future,
over orange and yellow to green for appointments in far future)

=back

=head1 TODO

 * what about default pre-alarm time? what about the same in org-mode?

 * what about locations attached to lon/lat, and automatic routing and
   automatic pre-alarm calculation?

 * it may happen that the update check happens just in the moment when
   emacs is about to save the file, leaving a half-written file. this
   may be workarounded by reading the file contents twice and compare
   if the contents are the same

 * more gui elements:
   * close button for alarm toplevel
   * reload button for data list window
   * iconify button for data list window
   * add another file into watcher list
   * remove a file from the watcher list
   * show the current watcher list
   * maybe some debugging helpers (time of the update, parsed contents...)

 * do things asynchronously (like reading files etc.)?

=head1 PREREQUISITES

Tk

=head1 AUTHOR

Slaven Rezic

=cut
