#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: org-daemon,v 1.25 2012/09/20 14:30:48 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use 5.008; # scalar open

use Getopt::Long;
use Time::Local qw(timelocal);
use Tk qw(tkinit Ev MainLoop);

{
    package Emacs::Org::Daemon::Date;
    sub new {
	my($class, %args) = @_;
	bless {%args}, $class;
    }
    sub id {
	my $self = shift;
	join '|', $self->{text}, $self->{date};
    }
    sub state {
	my $self = shift;
	my $now = time;
	if ($now >= $self->{epoch}) {
	    'due';
	} elsif (defined $self->{early_warning_epoch} && $now >= $self->{early_warning_epoch}) {
	    'early';
	} else {
	    'wait';
	}
    }
    sub formatted_text {
	my $self = shift;
	(my $formatted_text = $self->{text}) =~ s{\t}{ }g;
	$formatted_text =~ s{^\*+}{};
	$formatted_text =~ s{^\s+}{};
	$formatted_text =~ s{^(TODO|DONE|WAITING|WONTFIX|LATER)\s+}{};
	$formatted_text;
    }
}

my $small_font = 'sans 8';
my $default_early_warning = 30*60;
my $debug;
GetOptions("d|debug!" => \$debug,
	   "early-warning=i" => \$default_early_warning,
	  )
    or die "$0 [--debug] [--early-warning=seconds] orgfile ...";

my %open_warning;
my %org_files;
my %window_for_date;    # ($date_id -> $tk_window), for a (maybe) currently display date
my %seen_early_warning; # ($date_id -> 1)
my %seen_due_date;      # ($date_id -> 1)
my @lb_contents;
{
    my @org_files = @ARGV;
    if (!@org_files) {
	die "No org files given, exiting...\n";
    }
    %org_files = map { ($_, {}) } @org_files;
}

my $mw = tkinit;
$mw->iconify if !$debug;
my $lb = $mw->Scrolled("Listbox",
		       -width => 60,
		       -height => 6,
		       -scrollbars => "osoe",
		      )->pack(qw(-fill both -expand 1));
$lb->bind("<Double-1>" => sub {
	      show_date_by_index_in_emacs(shift->xyIndex);
	  });
$lb->Button(-padx => 0, -pady => 0, -borderwidth => 1,
	    -font => $small_font,
	    -text => 'Update',
	    -command => \&tk_do_one_iteration,
	   )->place(-relx => 1, -rely => 1, -anchor => 'se');

tk_do_one_iteration();
if ($debug) {
    $lb->repeat(3*1000, sub { tk_do_one_iteration() });
} else {
    # synchronize with full minute
    my(@l) = localtime;
    my $first_delay = 60 - $l[0];
    if ($first_delay) {
	$lb->after($first_delay*1000, sub {
		       tk_do_one_iteration();
		       $lb->repeat(60*1000, sub { tk_do_one_iteration() });
		   });
    } else {
	$lb->repeat(60*1000, sub { tk_do_one_iteration() });
    }
}

$mw->protocol('WM_DELETE_WINDOW', sub {
		  return if ($mw->messageBox
			     (-icon => "question",
			      -title => "Exit org-daemon",
			      -message => "Really exit org-daemon?",
			      -type => "YesNo",
			      -default => 'No',
			     ) =~ /no/i);
		  $mw->destroy;
	      });

#$mw->WidgetDump;
MainLoop;

sub show_date_by_index_in_emacs {
    my($index) = @_;
    my $date = $lb_contents[$index];
    die "No date at index $index" if !$date;
    $lb->after(100, sub { show_date_in_emacs($date) }); # do it after the buttonrelease event
}

sub show_date_in_emacs {
    my $date = shift;
    my $file = $date->{file};
    die "No file associated with given date" if !defined $file;
    my @cmd = ('emacsclient', '-n',
	       (defined $date->{line} ? '+'.$date->{line} : ()),
	       $file,
	      );
    system @cmd;
}

sub tk_do_one_iteration {
    if (check_for_updates()) {
	update_lb();
    }

    check_for_alarms();

    colorize_entries();
}

sub update_lb {
    $lb->delete(0, "end");
    @lb_contents = ();
    my @dates = map { @{ $_->{dates} } } values %org_files;
    @dates = sort { $a->{epoch} <=> $b->{epoch} } @dates;
    if (!@dates) {
	$lb->insert("end", "<no dates>");
    } else {
	for my $date (@dates) {
	    $lb->insert("end", $date->formatted_text);
	    push @lb_contents, $date;
	}
    }
}

sub colorize_entries {
    for my $i (0 .. $#lb_contents) {
	my $duration = $lb_contents[$i]->{epoch} - time;
	my($fg, $bg) = ('black', 'green');
	if ($duration < 3600) {
	    ($fg, $bg) = ('white', 'red');
	} elsif ($duration < 86400) {
	    ($fg, $bg) = ('black', 'orange');
	} elsif ($duration < 86400*7) {
	    ($fg, $bg) = ('black', 'yellow');
	}
	$lb->itemconfigure($i, -foreground => $fg, -background => $bg);
    }
}

sub check_for_alarms {
    my %active;
    my @dates = map { @{ $_->{dates} } } values %org_files;
    my $date_i = -1;
    for my $date (@dates) {
	$date_i++;
	my $date_id = $date->id;
	$active{$date_id} = 1;
	my $date_state = $date->state;
	if ($date_state =~ m{^(early|due)$}) {
	    my $is_early_warning = $date_state eq 'early';
	    my $t = $window_for_date{$date_id};
	    if ($t && Tk::Exists($t)) {
		next if $t->{DateState} eq $date_state; # nothing changed
	    }
	    if ($date_state eq 'early') {
		if ($seen_early_warning{$date_id}) {
		    next; # user already saw the early warning and clicked it away, don't redisplay
		} else {
		    $seen_early_warning{$date_id} = 1;
		}
	    } elsif ($date_state eq 'due') {
		if ($seen_due_date{$date_id}) {
		    next;
		} else {
		    $seen_due_date{$date_id} = 1;
		}
	    }

	    my %colargs    = (
			      -background => ($is_early_warning ? 'orange' : 'red'),
			      -foreground => ($is_early_warning ? 'black'  : 'white'),
			     );
	    my %smlbtnargs = (-font => $small_font);
	    my %t_args = (
			  -title => ($is_early_warning ? "Early Warning" : "Alarm!"),
			  %colargs,
			 );

	    if ($t && Tk::Exists($t)) {
		# something changed: early -> due
		$t->configure(%t_args);
		$_->destroy for $t->children;
		$t->{OverflowCounter}->cancel;
		$t->deiconify;
		$t->raise;
		$t->{DateState} = $date_state;
	    } else {
		$t = $mw->Toplevel(%t_args);
		$t->bind($_ => sub { $t->destroy })
		    for ('<Escape>', '<Control-q>');
		$t->{DateId} = $date_id;
		$t->{DateState} = $date_state;
	    }
	    $t->Label(-text => (($is_early_warning ? "Early warning:\n" : "")
				. $date->formatted_text),
		      -justify => 'left',
		      -font => 'sans 24',
		      %colargs,
		     )->pack(qw(-fill x -expand 1));
	    my $overflow = ($is_early_warning ? "" : "+00:00");
	    $t->Label(-textvariable => \$overflow,
		      -justify => 'right',
		      -anchor => 'e',
		      %colargs, %smlbtnargs,
		     )->pack(qw(-side right));
	    $t->Button(-text => 'Edit',
		       -command => sub { show_date_in_emacs($date) },
		       -anchor => 'w',
		       -borderwidth => 1,
		       -highlightthickness => 0,
		       -padx => 1, -pady => 1,
		       %colargs, %smlbtnargs,
		      )->pack(qw(-side left));
	    if ($is_early_warning) {
		$t->{OverflowCounter} =
		    $t->repeat(1000, sub {
				   my $diff = $date->{epoch} - time;
				   if ($diff <= 0) { # may happen if the original date was deleted
				       $t->{OverflowCounter}->cancel;
				       $overflow = "";
				   } else {
				       $overflow = sprintf "-%02d:%02d", int($diff/60), $diff%60;
				   }
			       });
	    } else {
		$t->{OverflowCounter} =
		    $t->repeat(1000, sub {
				   my $diff = time - $date->{epoch};
				   $overflow = sprintf "+%02d:%02d", int($diff/60), $diff%60;
			       });
	    }

	    $Tk::platform = $Tk::platform; # peacify -w
	    if ($Tk::platform eq 'unix') {
		my($wrapper) = $t->wrapper;
		# set sticky flag for gnome and fvwm2
		eval q{
		    $t->property('set','_WIN_STATE','CARDINAL',32,[1],$wrapper); # sticky
		    $t->property('set','_WIN_LAYER','CARDINAL',32,[6],$wrapper); # ontop
		};
		warn $@ if $@;
	    }

	    eval { $t->attributes(-topmost => 1) };
	    warn $@ if $@;

	    $window_for_date{$date_id} = $t;
	}
    }

    # Cleanup outdated windows (not existing or very old dates)
    {
	my @destroy_w;
	$mw->Walk(sub {
		      my $w = shift;
		      if ($w->isa('Tk::Toplevel')) {
			  my $date_id = $w->{DateId};
			  if ($date_id && !$active{$date_id}) {
			      push @destroy_w, $w;
			  }
		      }
		  });
	$_->destroy for @destroy_w;
    }

    # cleanup data structures
    for my $ref (\%window_for_date, \%seen_early_warning, \%seen_due_date) {
	while(my($k) = each %$ref) {
	    if (!$active{$k}) {
		delete $ref->{$k};
	    }
	}
    }
}

sub check_for_updates {
    my $changes = 0;
    for my $org_file (keys %org_files) {
	my $org_data = $org_files{$org_file};
	my($modtime) = (stat($org_file))[9];
	if (!defined $modtime) {
	    # non-existing file
	    $org_data->{modified} = $modtime;
	    $org_data->{dates} = [];
	    open_warning($org_file);
	    $changes++;
	    next;
	}
	delete $open_warning{$org_file};
	if (!$org_data->{modified} || $org_data->{modified} < $modtime) {
	    $org_data->{dates} = [ find_dates_in_org_file($org_file) ];
	    $org_data->{modified} = $modtime;
	    $changes++;
	}
    }
    $changes;
}

sub find_dates_in_org_file {
    my($file) = @_;

    my @dates;

    # This is org-stamp-time-of-day-regexp constant from org.el,
    # version 4.67d

    # In newer org.el this seems to have an different format;
    # see org-time-stamp-formats

    # Additionaly the weekday is optional, some org-mode versions seem
    # to deal without the weekday.

    # '-count unit' is a private extension. It seems that org-mode
    # is ignoring everything after the recognized date/time.

    # The original org-stamp-time-of-day-regexp has the 2nd date
    # matched with a backreference (\1). This is wrong for dates
    # spanning over midnight, e.g.
    #
    #    <2010-12-03 Pet 20:00>--<2010-12-04 Sub 00:00>

    # Times may be H:MM or HH:MM

    my $date_qr           = qr{[0-9]{4}-[0-9]{2}-[0-9]{2}};
    my $wkday_qr          = qr{\w+[ ]+};
    my $date_and_wkday_qr = qr{$date_qr[ ]+(?:$wkday_qr)?};
    my $time_qr           = qr{[012]?[0-9]:[0-5][0-9]};
    my $headwarn_qr       = qr{-[0-9]+(?:s|min|h|d|w|m|y)};
    my $repeater_qr       = qr{(?:\.|\+)?\+[0-9]+(?:s|min|h|d|w|m|y)};
    my $org_stamp_time_of_day_regexp =
	qr{
	      <
	      ($date_and_wkday_qr)
	      ($time_qr)
	      (?:[ ]+$repeater_qr)?
	      (?:[ ]+($headwarn_qr))?
	      >
	      (--?
		  <$date_and_wkday_qr($time_qr)>
	      )?
      }x;

    my $fh;
 TRY_OPEN: {
	my $tries = $open_warning{$file} ? 1 : 10;
	for (1..$tries) {
	    open $fh, $file
		and last TRY_OPEN;
	    # maybe emacs is now in this moment writing to the file?
	    if ($tries > 1) {
		warn "NOTE: file '$file' probably vanished or is saved in this moment. Will retry again.\n";
		select undef, undef, undef, 0.1; # wait and retry
	    }
	}
	# nope, file probably permanently vanished
	open_warning($file);
	return;
    }
    delete $open_warning{$file};

    my $buf = "";
 TRY_READ: {
	for (1..10) {
	    local $/ = undef;
	    $buf .= <$fh>;
	    select(undef,undef,undef,0.1);
	    seek $fh, 0, 1 or die $!;
	    last TRY_READ if eof($fh);
	    warn "NOTE: resuming reading file '$file' after " . length($buf) . " bytes...\n";
	}
    }

    my $linenumber = 0;
    my $last_item;
    open $fh, "<", \$buf
	or die "Cannot open scalar, should not happen!";
    binmode $fh, ':encoding(utf-8)'; # a modern default
    while(defined(my $textline = <$fh>)) {
	$linenumber++;
	chomp $textline;
	if ($textline =~ m{-\*-.*\bcoding:\s*([^;]+);.*-\*-}) {
	    my $encoding = $1;
	    binmode $fh, ':encoding(' . $encoding . ')';
	}

	if ($textline =~ m{^\*}) { # remember the last item
	    $last_item = $textline;
	}

	while ($textline =~ m{$org_stamp_time_of_day_regexp}g) {
	    my($date, $time, $head_warning) = ($1, $2, $3);
	    my($Y,$M,$D) = $date =~ m{^(\d{4})-(\d{2})-(\d{2})};
	    my($h,$m) = $time =~ m{^(\d{1,2}):(\d{2})};
	    my $epoch = timelocal(0,$m,$h,$D,$M-1,$Y);
	    if ($epoch >= time - 86400) { # we also collect also dates, just in case they are still displayed; also the early warning time is not considered here
		my $text;
		if (defined $last_item) {
		    if ($last_item ne $textline) {
			$text = "$last_item $textline";
		    } else {
			$text = $last_item;
		    }
		} else {
		    $text = $textline;
		}
		if ($text =~ m{^\*+\s+(?:DONE|WONTFIX)\b}) {
		    next; # ignore DONE and WONTFIX items
		}
		my %date_params = (epoch => $epoch,
				   date  => $date,
				   time  => $time,
				   text  => $text,
				   file  => $file,
				   line  => $linenumber,
				  );

		my $early_warning;
		if ($head_warning) {
		    $early_warning = _get_head_warning_secs($head_warning);
		}
		if (!defined $early_warning) {
		    $early_warning = $default_early_warning;
		}
		if ($early_warning > 0) {
		    $date_params{early_warning_epoch} = $epoch - $early_warning;
		}

		my $date = Emacs::Org::Daemon::Date->new(%date_params);
		my $date_state = $date->state;
		if (
		    ($date_state eq 'due' && $window_for_date{$date->id} && Tk::Exists($window_for_date{$date->id}))
		    ||
		    $date_state =~ m{^(wait|early)}
		   ) {
		    push @dates, $date;
		}
	    }
	}
    }

    @dates;
}

sub _get_head_warning_secs {
    my($s) = @_;
    if (my($count, $unit) = $s =~ m{-([0-9]+)(s|min|h|d|w|m|y)}) {
	$count * {s   => 1,
		  min => 60,
		  h   => 60*60,
		  d   => 60*60*24,
		  w   => 60*60*24*7,
		  # as suggested in org-get-wdays in org.el
		  m   => 60*60*24*30.4,
		  y   => 60*60*24*365.25,
		 }->{$unit};
    } else {
	warn "Cannot parse '$s'";
	undef;
    }
}

sub open_warning {
    my $file = shift;
    $open_warning{$file} ||= 0;
    if ($open_warning{$file} > 3) {
    } elsif ($open_warning{$file} == 3) {
	warn "Can't open $file: $!. Won't warn anymore!\n";
    } else {
	warn "Can't open $file: $!";
    }
    $open_warning{$file}++;
}

__END__

=head1 NAME

org-daemon - watch for appointments in org-mode files

=head1 SYNOPSIS

    org-daemon [--debug] [--early-warning=seconds] orgfile ... &

=head1 DESCRIPTION

B<org-daemon> is a Perl/Tk program which watches one or more emacs
org-mode files for appointments, that is, entries in the form of C<<
<YYYY-MM-DD AAA HH:MM> >> and fires alarms.

=head1 OPTIONS

=over

=item --debug

Turn on debugging mode. Currently this means: do not iconify
appointment list by default, and check every 3 seconds instead every
60 seconds.

=item --early-warning=I<seconds>

There's an warning before the real alarm 30 minutes (1800 seconds)
before. This option can be used to change this period. Use 0 to turn
early warnings off completely.

=back

=head2 FEATURES

=over

=item * Watch all given files periodically every minute (or in
C<-debug> mode every three seconds)

=item * Iconified list of next appointments, with entries in different
colors (red for appointments in near future, over orange and yellow to
green for appointments in far future)

=item * By double-clicking on an entry in the appointment list, or
clicking on the Edit button in the alarm window, the corresponding
entry will be shown in emacs itself (needs B<emacsclient> and emacs
has to be put into C<server-start> mode)

=item * Show an early warning 30 minutes before (or the period
specified with C<--early-warning>. Individual early warnings may be
specified with the following extended org syntax: C<< <YYYY-MM-DD AAA
HH:MM -CountUnit> >>, where Unit may be one of s (seconds), min
(minutes), h (hours), w (weeks), m (months), and y (years). Example:

     <2009-12-25 Fr 12:00 -10min>

=back

=head1 TODO

 * it would be nice if it was possible to specify individual pre-alarm
   times in org-mode and use them in org-daemon

 * what about locations attached to lon/lat, and automatic routing and
   automatic pre-alarm calculation?

 * it may happen that the update check happens just in the moment when
   emacs is about to save the file, leaving a half-written file. this
   may be workarounded by reading the file contents twice and compare
   if the contents are the same

 * more gui elements:
   * close button for alarm toplevel
   * reload button for data list window
   * iconify button for data list window
   * add another file into watcher list
   * remove a file from the watcher list
   * show the current watcher list
   * maybe some debugging helpers (time of the update, parsed contents...)

 * do things asynchronously (like reading files etc.)?

=head1 PREREQUISITES

Tk

=head1 AUTHOR

Slaven Rezic

=cut
