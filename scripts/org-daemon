#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: org-daemon,v 1.1 2009/02/07 16:36:25 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;

use Getopt::Long;
use Time::Local qw(timelocal);
use Tk;

my $debug;
GetOptions("d|debug!" => \$debug)
    or die "$0 [-debug] orgfile ...";

my %org_files;
my %alarmed;
{
    my @org_files = @ARGV;
    if (!@org_files) {
	die "No org files given, exiting...\n";
    }
    %org_files = map { ($_, {}) } @org_files;
}

my $mw = tkinit;
$mw->iconify if !$debug;
my $lb = $mw->Scrolled("Listbox", -scrollbars => "osoe")->pack(qw(-fill both -expand 1));
$lb->repeat(($debug?3:60)*1000, sub { tk_do_one_iteration() });
tk_do_one_iteration();

MainLoop;

sub tk_do_one_iteration {
    if (check_for_updates()) {
	$lb->delete(0, "end");
	my @dates = map { @{ $_->{dates} } } values %org_files;
	@dates = sort { $a->{epoch} <=> $b->{epoch} } @dates;
	if (!@dates) {
	    $lb->insert("end", "<no dates>");
	} else {
	    for my $date (@dates) {
		$lb->insert("end", $date->{line});
	    }
	}
    }

    check_for_alarms();
}

sub check_for_alarms {
    my @dates = map { @{ $_->{dates} } } values %org_files;
    for my $date (@dates) {
	if ($date->{epoch} <= time && !$alarmed{$date->{line}}) {
	    my $t = $mw->Toplevel(-title => "Alarm!");
	    $t->Label(-text => $date->{line}, # . "\n" . $date->{date} . " " . $date->{time},
		      -justify => 'left',
		      -font => 'sans 24',
		      , -background => 'red', -foreground => 'white',
		     )->pack;

	    $Tk::platform = $Tk::platform; # peacify -w
	    if ($Tk::platform eq 'unix') {
		my($wrapper) = $t->wrapper;
		# set sticky flag for gnome and fvwm2
		eval q{
		    $t->property('set','_WIN_STATE','CARDINAL',32,[1],$wrapper); # sticky
		    $t->property('set','_WIN_LAYER','CARDINAL',32,[6],$wrapper); # ontop
		};
		warn $@ if $@;
	    }

	    $alarmed{$date->{line}} = 1;
	}
    }
}

sub check_for_updates {
    my $changes = 0;
    for my $org_file (keys %org_files) {
	my $org_data = $org_files{$org_file};
	my($modtime) = (stat($org_file))[9];
	if (!defined $modtime) {
	    # non-existing file
	    $org_data->{modified} = $modtime;
	    $org_data->{dates} = [];
	    $changes++;
	    next;
	}
	if (!$org_data->{modified} || $org_data->{modified} < $modtime) {
	    $org_data->{dates} = [ find_dates_in_org_file($org_file) ];
	    $org_data->{modified} = $modtime;
	    $changes++;
	}
    }
    $changes;
}

sub find_dates_in_org_file {
    my($file) = @_;

    my @dates;

    # This is org-stamp-time-of-day-regexp constant from org.el,
    # version 4.67d
    my $org_stamp_time_of_day_regexp = qr{
					     <
					     ([0-9]{4}-[0-9]{2}-[0-9]{2}[ ]+\w+[ ]+)
					     ([012][0-9]:[0-5][0-9])>
					     (--?
						 <\1([012][0-9]:[0-5][0-9])>
					     )?
				     }x;

    open my $fh, $file
	or die "Can't open $file: $!";
    while(defined(my $line = <$fh>)) {
	while ($line =~ m{$org_stamp_time_of_day_regexp}g) {
	    my($date, $time) = ($1, $2);
	    my($Y,$M,$D) = $date =~ m{^(\d{4})-(\d{2})-(\d{2})};
	    my($h,$m) = $time =~ m{^(\d{1,2}):(\d{2})};
	    my $epoch = timelocal(0,$m,$h,$D,$M-1,$Y);
	    if ($epoch >= time) {
		push @dates, { epoch => $epoch,
			       date  => $date,
			       time  => $time,
			       line  => $line,
			     };
	    }
	}
    }

    @dates;
}

__END__
