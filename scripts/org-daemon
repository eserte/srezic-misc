#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: org-daemon,v 1.5 2009/02/09 15:08:31 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;

use Getopt::Long;
use Time::Local qw(timelocal);
use Tk qw(tkinit Ev MainLoop);

{
    package Emacs::Org::Daemon::Date;
    sub new { my $class = shift; bless {@_}, $class }
    sub id { shift->{text} }
}

my $debug;
GetOptions("d|debug!" => \$debug)
    or die "$0 [-debug] orgfile ...";

my %org_files;
my %alarmed;
my @lb_contents;
{
    my @org_files = @ARGV;
    if (!@org_files) {
	die "No org files given, exiting...\n";
    }
    %org_files = map { ($_, {}) } @org_files;
}

my $mw = tkinit;
$mw->iconify if !$debug;
my $lb = $mw->Scrolled("Listbox",
		       -width => 60,
		       -height => 6,
		       -scrollbars => "osoe",
		      )->pack(qw(-fill both -expand 1));
$lb->bind("<Double-1>" => sub {
	      show_date_in_emacs(shift->xyIndex);
	  });
$lb->repeat(($debug?3:60)*1000, sub { tk_do_one_iteration() });
tk_do_one_iteration();

MainLoop;

sub show_date_in_emacs {
    my($index) = @_;
    my $date = $lb_contents[$index];
    my $file = $date->{file};
    die "No file associated with date at index $index" if !defined $file;
    my @cmd = ('emacsclient', '-n',
	       (defined $date->{line} ? '+'.$date->{line} : ()),
	       $file,
	      );
    system @cmd;
}

sub tk_do_one_iteration {
    if (check_for_updates()) {
	update_lb();
    }

    colorize_entries();
    if (check_for_alarms()) {
	update_lb();
    }
}

sub update_lb {
    $lb->delete(0, "end");
    @lb_contents = ();
    my @dates = map { @{ $_->{dates} } } values %org_files;
    @dates = grep { !$alarmed{$_->id} } sort { $a->{epoch} <=> $b->{epoch} } @dates;
    if (!@dates) {
	$lb->insert("end", "<no dates>");
    } else {
	for my $date (@dates) {
	    $lb->insert("end", $date->{text});
	    push @lb_contents, $date;
	}
    }
}

sub colorize_entries {
    for my $i (0 .. $#lb_contents) {
	my $duration = $lb_contents[$i]->{epoch} - time;
	my($fg, $bg) = ('black', 'green');
	if ($duration < 3600) {
	    ($fg, $bg) = ('white', 'red');
	} elsif ($duration < 86400) {
	    ($fg, $bg) = ('black', 'orange');
	} elsif ($duration < 86400*7) {
	    ($fg, $bg) = ('black', 'yellow');
	}
	$lb->itemconfigure($i, -foreground => $fg, -background => $bg);
    }
}

sub check_for_alarms {
    my $changes = 0;
    my %seen;
    my @dates = map { @{ $_->{dates} } } values %org_files;
    for my $date (@dates) {
	$seen{$date->id}++;
	if ($date->{epoch} <= time && !$alarmed{$date->id}) {
	    my $t = $mw->Toplevel(-title => "Alarm!");
	    $t->Label(-text => $date->{text}, # . "\n" . $date->{date} . " " . $date->{time},
		      -justify => 'left',
		      -font => 'sans 24',
		      , -background => 'red', -foreground => 'white',
		     )->pack;

	    $Tk::platform = $Tk::platform; # peacify -w
	    if ($Tk::platform eq 'unix') {
		my($wrapper) = $t->wrapper;
		# set sticky flag for gnome and fvwm2
		eval q{
		    $t->property('set','_WIN_STATE','CARDINAL',32,[1],$wrapper); # sticky
		    $t->property('set','_WIN_LAYER','CARDINAL',32,[6],$wrapper); # ontop
		};
		warn $@ if $@;
	    }

	    eval { $t->attributes(-topmost => 1) };
	    warn $@ if $@;

	    $alarmed{$date->id} = 1;
	    $changes++;
	}
    }

    # cleanup all dates
    for my $id (keys %alarmed) {
	if (!$seen{$id}) {
	    delete $alarmed{$id};
	}
    }

    $changes;
}

sub check_for_updates {
    my $changes = 0;
    for my $org_file (keys %org_files) {
	my $org_data = $org_files{$org_file};
	my($modtime) = (stat($org_file))[9];
	if (!defined $modtime) {
	    # non-existing file
	    $org_data->{modified} = $modtime;
	    $org_data->{dates} = [];
	    $changes++;
	    next;
	}
	if (!$org_data->{modified} || $org_data->{modified} < $modtime) {
	    $org_data->{dates} = [ find_dates_in_org_file($org_file) ];
	    $org_data->{modified} = $modtime;
	    $changes++;
	}
    }
    $changes;
}

sub find_dates_in_org_file {
    my($file) = @_;

    my @dates;

    # This is org-stamp-time-of-day-regexp constant from org.el,
    # version 4.67d

    # In newer org.el this seems to have an different format;
    # see org-time-stamp-formats

    # Additionaly the weekday is optional, some org-mode versions seem
    # to deal without the weekday.

    my $org_stamp_time_of_day_regexp = qr{
					     <
					     ([0-9]{4}-[0-9]{2}-[0-9]{2}[ ]+(?:\w+[ ]+)?)
					     ([012][0-9]:[0-5][0-9])>
					     (--?
						 <\1([012][0-9]:[0-5][0-9])>
					     )?
				     }x;

    open my $fh, $file
	or die "Can't open $file: $!";
    while(defined(my $text = <$fh>)) {
	chomp $text;
	if ($text =~ m{-\*-.*\bcoding:\s*([^;]+);.*-\*-}) {
	    my $encoding = $1;
	    binmode $fh, ':encoding(' . $encoding . ')';
	}

	while ($text =~ m{$org_stamp_time_of_day_regexp}g) {
	    my($date, $time) = ($1, $2);
	    my($Y,$M,$D) = $date =~ m{^(\d{4})-(\d{2})-(\d{2})};
	    my($h,$m) = $time =~ m{^(\d{1,2}):(\d{2})};
	    my $epoch = timelocal(0,$m,$h,$D,$M-1,$Y);
	    if ($epoch >= time) {
		push @dates, Emacs::Org::Daemon::Date->new(epoch => $epoch,
							   date  => $date,
							   time  => $time,
							   text  => $text,
							   file  => $file,
							   line  => $.,
							  );
	    }
	}
    }

    @dates;
}

__END__

=head1 NAME

org-daemon - watch for appointments in org-mode files

=head1 SYNOPSIS

    org-daemon orgfile ... &

=head1 DESCRIPTION

B<org-daemon> is a Perl/Tk program which watches one or more emacs
org-mode files for appointments, that is, entries in the form of C<<
<YYYY-MM-DD AAA HH:MM> >> and fires alarms.

=head2 FEATURES

=over

=item * Watch all given files periodically every minute (or in
C<-debug> mode every three seconds)

=item * By double-clicking on an entry, shows the corresponding entry
in emacs itself (needs B<emacsclient> and emacs has to be put into
C<server-start> mode)

=item * Iconified main window shows the list of next appointments,
with entries in different colors (red for appointments in near future,
over orange and yellow to green for appointments in far future)

=back

=head1 TODO

 * what about default pre-alarm time? what about the same in org-mode?

 * what about locations attached to lon/lat, and automatic routing and
   automatic pre-alarm calculation?

=head1 PREREQUISITES

Tk

=head1 AUTHOR

Slaven Rezic

=cut
