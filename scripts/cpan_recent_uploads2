#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2008,2013,2014,2015 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use CPAN;
use Getopt::Long;
my $LWP_UserAgent;
my %LWP_options;
BEGIN {
    if (eval q{ use LWP::UserAgent::WithCache 0.10; 1 }) {
	$LWP_UserAgent = 'LWP::UserAgent::WithCache';
	%LWP_options = (
			'namespace' => 'lwp-cache',
			'cache_root' => "$ENV{HOME}/.cache",
			'default_expires_in' => 600,
		       );
    } else {
	require LWP::UserAgent;
	$LWP_UserAgent = 'LWP::UserAgent';
    }
}
use YAML::Syck qw(Load);

{
    package MyCPANShell;
    use vars qw(@ISA $VERBOSE);
    @ISA = $CPAN::Frontend;
    sub myprint {
	if ($VERBOSE) {
	    shift;
	    print STDERR @_;
	}
    }
    sub mywarn  { shift->myprint(@_) }
    $CPAN::Frontend = "MyCPANShell";
}

my($from, $to);
my $url;
my $v;
my $warn_old;
my $only_stable;
my $only_dists;
my $only_indexed;
my $skip_perl6;

GetOptions("from=s" => \$from,
	   "to=s"   => \$to,
	   "url=s"  => \$url,
	   "onlystable|stable!" => \$only_stable,
	   "onlydists!" => \$only_dists,
	   "onlyindexed|indexed!" => \$only_indexed,
	   "skipperl6!" => \$skip_perl6,
	   "v+"     => \$v,
	   "warnold" => \$warn_old,
	  ) or die <<EOF;
usage: $0 [-from epoch] [-to epoch] [-url ...] [-stable | -indexed] [-skipperl6] [-onlydists] [-v [-v ...]] [-warnold]
EOF

my $now = time;

my %unit2secs = (
		 "s" => 1,
		 "m" => 60,
		 "h" => 3600,
		 "d" => 86400,
		);
my $units_qr = '(?:' . join('|', map { quotemeta } keys %unit2secs) . ')'; $units_qr = qr{$units_qr};

for ($from, $to) {
    if (defined $_ && $_ =~ m{-(\d+)($units_qr)$}) {
	my($val, $unit) = ($1, $2);
	$_ = "-" . ($val * $unit2secs{$unit});
    }
}

for ($from, $to) {
    if (defined $_ && $_ !~ m{^-?\d+$}) {
	die "Invalid -from/-to value (translated: $_)";
    }
}

for ($from, $to) {
    if (defined $_ && m{^-(.*)}) {
	$_ = $now - $1;
    }
}

if (!defined $from && !defined $to) {
    $from = $now - 86400;
    $to   = $now;
} elsif (!defined $from) {
    $from = $to - 86400;
} elsif (!defined $to) {
    $to = $now;
}
$to = $now if $to > $now;

if ($v) {
    $MyCPANShell::VERBOSE = 1;
}

warn "INFO: Range from " . scalar(localtime $from) . " to " . scalar(localtime $to) . "\n" if $v;

# XXX is this really necessary?
$ENV{FTP_PASSIVE} = 1;

if (!$url) {
    cpan_handleconfig();
## unfortunately my http mirrors are not as recent as funet:
#    ($url) = grep { m{^http://} } @{ $CPAN::Config->{urllist} }; # prefer http
    if (!$url) {
	$url = $CPAN::Config->{urllist}->[0];
    }
}

if (!$url) {
    die "Cannot get any URL from urllist and no -url specified on cmdline";
}

$url =~ s{/+$}{}; # normalize?

my $ua = $LWP_UserAgent->new(%LWP_options);

my $recent = $url . "/authors/RECENT-1h.yaml";
warn "INFO: Fetching from $recent...\n" if $v;
my $resp = $ua->get($recent);
if (!$resp->is_success) {
    die "Error while fetching $recent: " . $resp->status_line;
}
my $recent_data = Load($resp->decoded_content);

if ($warn_old) {
    my $time = $recent_data->{meta}->{Producers}->{time};
    my $error_message;
    if (!$time) {
	$error_message = 'Cannot get data path meta.Producers.time (zero or non-existent)';
    } else {
	my $age = time - $time;
	my $accept_age = 3600*6; # assume every six hours an update
	if ($age > $accept_age) {
	    $error_message = sprintf "%s is too old: age is %.1f hour(s), but we accept only %.1f hour(s) or younger", $recent, $age/3600, $accept_age/3600;
	}
    }
    if ($error_message) {
	if (eval {
	    standalone_message_box(-message => $error_message);
	}) {
	    warn $error_message;
	}
    }
}

my @aggregator = @{ $recent_data->{meta}->{aggregator} || [] };

if ($v && $v >= 2) {
    *debug      = sub { warn "DEBUG: $_[0]\n" };
    *debug_code = sub { $_[0]->() };
} else {
    *debug      = sub { };
    *debug_code = sub { };
}

my %deleted_dist;

if ($only_indexed) {
    maybe_refresh_packages_index();
}
 
GATHER_DATA: {
    my $last_epoch;
    while() {
	for my $entry (@{ $recent_data->{recent} }) {
	    debug_code(sub {
			   my @t = gmtime $entry->{epoch}; $t[4]++; $t[5]+=1900;
			   my($frac) = $entry->{epoch} =~ m{(\.\d+)$};
			   $frac = ".0" if !$frac;
			   my $date = sprintf "%04d-%02d-%02d %02d:%02d:%02d%s", @t[5,4,3,2,1,0], $frac;
			   debug("$date $entry->{path}");
		       });
	    debug("finished!"), last GATHER_DATA if $entry->{epoch} < $from;

	    # deleted flag
	    my $path = $entry->{path};
	    if ($entry->{type} eq 'delete') {
		$deleted_dist{$path} = 1;
		next;
	    }
	    debug("$path was marked as deleted"), next if exists $deleted_dist{$path};
	    debug("unhandled entry type: $entry->{type}"), next if $entry->{type} ne 'new';
	    debug("skipping over (already seen)"), next if defined $last_epoch && $entry->{epoch} >= $last_epoch;
	    $last_epoch = $entry->{epoch};
	    debug("skipping over (to)"), next if $entry->{epoch} > $to;
	    # strip "id/" from $path
	    debug("ignore (not in id)"), next if $path !~ m{^id/(.*)};
	    $path = $1;
	    if ($only_dists || $only_indexed) {
		# same list of extensions as in CPAN::DistnameInfo
		debug("ignore (not a dist)"), next if $path !~ m{(\.zip|\.tgz|\.tar\.(z|gz|bz2))$}i;
	    } else {
		debug("ignore (not a dist)"), next if $path =~ m{(\.patch|\.patch\.gz|CHECKSUMS|\.readme|\.meta)$};
		debug("ignore (not a dist)"), next if $path =~ m{/?00whois.(html|xml)$};
	    }
	    if ($skip_perl6) {
		debug("ignore (perl6 dist)"), next if $path =~ m{/Perl6/};
	    }
	    if ($only_stable) {
		require CPAN::DistnameInfo;
		CPAN::DistnameInfo->VERSION('0.10'); # support for -TRIAL
		my $distinfo = CPAN::DistnameInfo->new($path);
		debug("developer version"), next if $distinfo->maturity ne 'released';
	    }
	    if ($only_indexed) {
		my $do = eval { CPAN::Shell->expand('Distribution', $path) };
		debug('not indexed'), next if !$do;
	    }
	    print $path, "\n";
	}
	last GATHER_DATA if !@aggregator;
	my $next_aggregator = shift @aggregator;
	my $next_recent_url = $url . "/authors/RECENT-" . $next_aggregator . ".yaml";
	warn "Fetching from $next_recent_url...\n" if $v;
	my $resp = $ua->get($next_recent_url);
	if (!$resp->is_success) {
	    die "Error while fetching $next_recent_url: " . $resp->status_line;
	}
	$recent_data = Load($resp->decoded_content);
    }
}

{
    my $CPAN_HandleConfig_loaded;
    sub cpan_handleconfig {
	if (!$CPAN_HandleConfig_loaded) {
	    CPAN::HandleConfig->load;
	    $CPAN_HandleConfig_loaded = 1;
	}
    }
}

# Side effects:
# - loads CPAN config
# - adjust urllist (by adding $url)
# - may set index_expire to a high value (to disable forced reloads)
# - may refresh the CPAN package index
sub maybe_refresh_packages_index {
    cpan_handleconfig();
    unshift @{ $CPAN::Config->{urllist} }, $url;

    # Check whether we have to call force_reload(), or
    # if the 02packages.details.txt.gz file is already
    # fresh enough.
    my $packages_file = $CPAN::Config->{keep_source_where} . '/modules/02packages.details.txt.gz';
    my $need_forced_reload = 1;
    my(@s) = stat($packages_file);
    if (@s) {
	my $ua = LWP::UserAgent->new; # don't use ::WithCache ua here
	my $packages_url = $url . '/modules/02packages.details.txt.gz';
	my $res = $ua->head($packages_url);
	if ($res->code == 200) {
	    if ($res->last_modified <= $s[9]) {
		warn "INFO: $packages_url was not modified\n" if $v;
		$need_forced_reload = 0;
	    } else {
		warn "INFO: $packages_url was modified\n" if $v;
	    }
	} else {
	    warn "ERROR: HEAD $packages_url did not return 200 OK, but: " . $res->status_line. "\n";
	}
    } else {
	warn "INFO: packages file $packages_file does not exist (first-time fetch?)\n" if $v;
    }

    if ($need_forced_reload) {
	debug("do forced reload of CPAN indexes");
	CPAN::Index->force_reload();
    } else {
	$CPAN::Config->{index_expire} = 99999;
	debug("no forced reload of CPAN indexes necessary");
    }
}

# REPO BEGIN
# REPO NAME standalone_message_box /home/e/eserte/src/srezic-repository 
# REPO MD5 c4592f93ed4afa4f6a93d9ff38d2e905

=head2 standalone_message_box

=for category Tk

A message box which can be invoked without Tk being loaded before. It
uses the same arguments as messageBox from Tk, but is always invoked
as a function. Return the messageBox answer.

=cut

sub standalone_message_box {
    my %args = @_;
    require Tk;
    my $mw_created;
    my(@mw) = Tk::MainWindow::Existing();
    if (!@mw) {
	push @mw, MainWindow->new();
	$mw[0]->withdraw;
	$mw_created++;
    }
    $args{-icon}  = 'error' unless exists $args{-icon};
    $args{-title} = 'Error' unless exists $args{-error};
    $args{-type}  = 'OK'    unless exists $args{-type};
    my $answer = $mw[0]->messageBox(%args);
    if ($mw_created) {
	$mw[0]->destroy;
    }
    $answer;
}

# REPO END

