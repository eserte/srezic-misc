#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: ical2org,v 1.11 2009/08/07 13:29:23 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2009 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use Data::ICal   qw();
use File::Spec   qw();
use File::Temp   qw(tempfile);
use Getopt::Long;
use POSIX        qw(strftime);
use Time::Local  qw(timelocal timegm);

my $itemdepth = 2;
my $do_alarm_handling = 1;
GetOptions("itemdepth=i" => \$itemdepth,
	   "alarm!"     => \$do_alarm_handling,
	  )
    or die "usage: $0 [-itemdepth ...] [-noalarm]";

my $itemstart = "*" x $itemdepth . " ";
my $propstart = " " x ($itemdepth+1);

if (!@ARGV) {
    warn "Reading from STDIN...\n";
    @ARGV = "-";
}

for my $file (@ARGV) {
    if ($file eq '-') {
	my($tmpfh, $tmpfile)=tempfile(UNLINK => 1, SUFFIX => ".vcs");
	while(<STDIN>) {
	    print $tmpfh $_
		or die $!;
	}
	close $tmpfh or die $!;
	$file = $tmpfile;
    }
    my $ical;
    for my $val10_flag (0, 1) {
	# Data::ICal::parse is too noisy for real-existing ical files
	# (e.g. from the N95, or from org-mode), and I did not find
	# another way to quieten the carp() there.
	open my $OLDERR, ">&", \*STDERR or die $!;
	open(STDERR, ">", File::Spec->devnull) or die $!;
	$ical = Data::ICal->new(filename => $file, vcal10 => $val10_flag);
	close STDERR;
	open(STDERR, ">&", $OLDERR) or die $!;
	last if $ical;
    }
    if (!$ical) {
	warn "Cannot recognize file $file as ical file '" . $ical->error_message . "', skipping...\n";
	next;
    }
    for my $entry (@{ $ical->entries }) {
	next if $entry->ical_entry_type ne 'VEVENT';
	my $props = $entry->properties;
	# XXX use decoded_value?
	my $dtstart  = eval { $props->{dtstart}->[0]->value };
	my $begin    = icaldate_to_orgdate($dtstart);
	$begin = alarm_handling($begin, $entry) if $begin && $do_alarm_handling;
	my $end      = icaldate_to_orgdate(eval { $props->{dtend}->[0]->value });
	my $id       = icaluid_to_orgid(eval { $props->{uid}->[0]->value });
	my $location = eval { $props->{location}->[0]->value };
	my $summary  = eval { $props->{summary}->[0]->value } || "no summary";
	my $description = eval { $props->{description}->[0]->value } || undef;
	my @attendees;
	for my $attendee (@{ $props->{attendee} || [] }) {
	    push @attendees, $attendee->{value} if $attendee->{value};
	}
	print $itemstart . $summary . ($begin ? " $begin" : "") . ($end ? "--$end" : "") . "\n";
	my $leadingspace = " "x length($itemstart);
	if (defined $description) {
	    print join("", map { $leadingspace . $_ . "\n" } split /\n/, $description);
	}
	for my $attendee (@attendees) {
	    print $leadingspace, "* ", $attendee, "\n";
	}
	if (defined $id || defined $location) {
	    print $propstart, ":PROPERTIES:\n";
	    if (defined $id) {
		print $propstart, ":ID: $id\n";
	    }
	    if (defined $location) {
		print $propstart, ":LOCATION: $location\n";
	    }
	    print $propstart, ":END:\n";
	}
    }
}

sub alarm_handling {
    my($org_date, $vevent) = @_;
    my $vevent_props = $vevent->properties;
    my $dtstart = eval { $vevent_props->{dtstart}->[0]->value };
    my $alarm;

    # VALARM
    my($valarm) = grep { $_->ical_entry_type eq 'VALARM' } @{ $vevent->entries };
    if ($valarm) {
	my $valarm_props = $valarm->properties;
	$alarm = eval { $valarm_props->{trigger}->[0]->{value} };
    }
    if (!$valarm and $alarm = eval{ $vevent_props->{aalarm}->[0]->value }) {
	($alarm) = split /;/, $alarm; # XXX what are the other fields?
    }
    if ($alarm) {
	my $alarm_epoch = _isodate_to_epoch($alarm);
	if (!defined $alarm_epoch) {
	    warn "Cannot parse valarm.trigger or aalarm field '$alarm', ignoring.\n";
	} else {
	    my $dtstart_epoch = _isodate_to_epoch($dtstart);
	    if (defined $alarm_epoch) {
		if ($alarm_epoch >= $dtstart_epoch) {
		    warn "Ignoring specified alarm '$alarm' for date '$dtstart'...\n";
		} else {
		    my $alarm_spec = '-';
		    my $delta = $dtstart_epoch-$alarm_epoch;
		    if ($delta % 3600 == 0) {
			$alarm_spec .= ($delta/3600).'h';
		    } elsif ($delta % 60 == 0) {
			$alarm_spec .= ($delta/60).'min';
		    } else {
			$alarm_spec .= $delta.'s';
		    }
		    $org_date =~ s{>}{ $alarm_spec>};
		}
	    }
	}
    }
    $org_date;
}

sub _isodate_to_epoch {
    my $dt = shift;
    if (my($Y,$M,$D,$h,$m,$s,$tz) = $dt =~ m{^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(Z)?$}) {
	my $epoch;
	if ($tz) {
	    if ($tz eq 'Z' || $tz eq '+0000') {
		$epoch = timegm($s,$m,$h,$D,$M-1,$Y);
	    } else {
		warn "Cannot deal with timezone '$tz' in date '$dt'";
		return undef;
	    }
	} else {
	    $epoch = timelocal($s,$m,$h,$D,$M-1,$Y);
	}
	$epoch;
    } else {
	undef;
    }
}

sub icaldate_to_orgdate {
    my $dt = shift;
    return if !defined $dt;
    if (defined(my $epoch = _isodate_to_epoch($dt))) {
	strftime "<%Y-%m-%d %a %H:%M>", localtime $epoch;
    } elsif (my($Y,$M,$D) = $dt =~ m{^(\d{4})(\d{2})(\d{2})$}) {
	sprintf "%04d-%02d-%02d", $Y, $M, $D;
    } else {
	warn "Cannot parse date '$dt'!";
	undef;
    }
}

sub icaluid_to_orgid {
    my $uid = shift;
    return if !defined $uid;
    $uid =~ s{^\s+(?:TS|DL|SC)-}{}; # XXX why? The space seems to be a org-mode bug (report!) The prefixes stand for timestamp, deadline, scheduled
    $uid;
}

__END__

=head1 NAME

ical2org - format ical entries into org-mode-compatible entries

=head1 SYNOPSIS

    ical2org [-itemdepth ...] [-noalarm] ical.vcs ...
    # and then paste the output into an org-mode emacs buffer

=head1 TODO

 * Maybe work with L<Date::ICal> for parsing dates?

 * timezone handling is missing

=head1 PREREQUISITES

Data::ICal

=head1 AUTHOR

Slaven Rezic

=cut
