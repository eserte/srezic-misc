#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2007, 2008, 2009, 2011, 2012, 2013, 2014, 2015, 2016 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use Config qw(%Config);
use Getopt::Long;
use CPAN;
use CPAN::DistnameInfo 0.10; # .tar.bz2 support, TRIAL support
use IO::Handle;
use File::Temp qw(tempfile tempdir);
use File::Path qw(mkpath rmtree);
use POSIX ();
use Sys::Hostname qw(hostname);

sub save_pwd (&);

$ENV{PATH} = $ENV{PATH} . $Config{path_sep} . $FindBin::RealBin; # e.g. for sudo_keeper

my $start_time = time;

if ($^O eq 'MSWin32' && !$ENV{HOME}) {
    $ENV{HOME} = "$ENV{HOMEDRIVE}$ENV{HOMEPATH}";
}

my $addarch = $Config{myarchname} ? "_$Config{myarchname}" : "";
my $cpan_smoke_log  = "$ENV{HOME}/.cpan_smoke_modules$addarch.log";
my $cpan_smoke_typescripts_dir = "$ENV{HOME}/.cpan_smoke_modules_typescripts";
my $rc_file = "$ENV{HOME}/.cpansmokemodulesrc";
my $pause_file = "$ENV{HOME}/.cpansmokemodulespause";

my @perls;
my $dists;
my $reports_sent_seek_pos;
my @pv;
my $perlr;
my $do_action = "test"; # and report
my @post_actions;
my $warntimeout = 60;
my $n;
my $r;
my $rr; # reverse a working set (-splitdists) only
my $use_sqlite = 0; # not default anymore --- sometimes there are locking problems
my $fl;
my $wait;
my $batch = 1;
my $for_parallel_smoker = 0;
my $all_perls = 1; # Usually I want them all
my $skip_system_perl;
my @skip_perls;
my $do_this_perl;
my $build_dir_reuse = 0; # not default - startup is tooo slow
my $per_day_build_dir = 1; # currently it's really a build dir for every 3 hours, not a daily one
my $split_dists = $^O eq 'MSWin32' ? 5 : 40;
my $has_xterm_conf;
my $skip_tested;
my $skip_tested_fail;
my $skip_tested_pass;
my $use_reports_sent_cache_file;
my $reports_sent_cache_pl_called;
my $test_unpatched;
my $save_reports = 1;
my $do_create_report_directories = 1;
my $auto_mount;
my $auto_umount;
my $need_auto_umount = 0;
my $reports_workflow_dir;
my $reports_workflow_default_dir = "$ENV{HOME}/var/cpansmoker";
my $min_build_dir_avail = 2_000_000_000; # 2G
my $min_build_dir_cleanup; # when to start cleanup
my $min_tmp_dir_avail   = 50_000_000; # 50M
my $min_dir_inodes_percent = 5;
my $debug;
my $destroy_perl_in_path = 0;
my $add_this_perl_path;
my @pre_dist_or_mods;
my @cpan_conf;
my @cpan_conf_unchecked;
my $as_root;
my $efence;
my $strace;
my $truss;
my $ktrace;
my $do_typescript; # undef means: maybe
my $do_filemon;
my $typescript_file;
my $use_distroprefs = 1;
my $use_limits = 1;
my $prefs_dir;
my $signal_end = 1;
my $module_printused;
my $unkind = 0;
my $mirror_url = 'http://cpan.cpantesters.org/';
my @hidemod;
my $time_fake;
my $use_vncserver;
my $x11_display;
my @touch_files;
my $reload_index;
my $hack_checksum_check_file = 1;
my $hack_skip_distropref_validation = 1;
my $ignore_history;
my $deterministic_hashes;
my $perl_hash_seed;
my $perl_perturb_keys;
my $do_report = 1;
my $use_sudo_keeper = 1; # if available
my $my_tmpdir;
my $stop_signal;
my $action_count = 0;
my $fail_if_nothing_done;
my $old_cpan_pm_hack;
my $sysdeps = ''; # '', 'verbose', 'batch'

# prepend extra options from rc file
if (-r $rc_file) {
    # Quick'n'dirty check if the rc file should be skipped
    if (grep { m{^--?skiprcfile$} } @ARGV) {
	@ARGV = grep { !m{^--?skiprcfile$} } @ARGV;
    } else {
	require Text::ParseWords;
	print STDERR "INFO: Reading extra options from $rc_file... ";
	open my $rcfh, $rc_file
	    or die "$rc_file exists and is readable, but cannot be opened?! Error: $!";
	my @file_ARGV;
	while(<$rcfh>) {
	    chomp;
	    next if /^\s*#/;
	    next if /^\s*$/;
	    push @file_ARGV, Text::ParseWords::shellwords($_);
	}
	print STDERR "extra options: " . (@file_ARGV ? "@file_ARGV" : '<none>') . "\n";
	unshift @ARGV, @file_ARGV;
    }
}

Getopt::Long::Configure('noauto_abbrev');
GetOptions("n" => \$n,
	   "r|reverse" => \$r,
	   "rr" => \$rr,
	   "a|allperls!" => \$all_perls,
	   "skipsystemperl|skip-system-perl" => \$skip_system_perl,
	   'skipperl|skip-perl=s@' => \@skip_perls,
	   "i|install" => sub { $do_action = "install" },
	   'reinstall' => sub { $do_action = 'reinstall' },
	   "shell" => sub {
	       $do_action = "shell";
	       $signal_end = 0; # we are interactive anyway...
	   },
	   "sudokeeper!" => \$use_sudo_keeper,
	   "warntimeout=i" => \$warntimeout,
	   'perl=s@' => \@perls,
	   'pv=s@' => \@pv,
	   'perlr|perl-reverse!' => \$perlr, # reverse list of perl versions
	   'thisperl' => \$do_this_perl,
	   'sqlite!' => \$use_sqlite,
	   'fl|filelist=s' => \$fl,
	   'unkind' => \$unkind,
	   'wait!' => \$wait,
	   'batch!' => \$batch,
	   'forparallelsmoker!' => \$for_parallel_smoker,
	   'builddirreuse!' => \$build_dir_reuse,
	   'perdaybuilddir!' => \$per_day_build_dir,
	   'splitdists=i' => \$split_dists,
	   'skiptested!' => \$skip_tested,
	   'skiptestedfail' => sub {
	       $skip_tested_fail = $skip_tested = 1;
	   },
	   'skiptestedpass' => sub {
	       $skip_tested_pass = $skip_tested = 1;
	   },
	   'usereportssentcache' => \$use_reports_sent_cache_file,
	   'testunpatched' => \$test_unpatched,
	   'report!' => \$do_report,
	   'savereports!' => \$save_reports,
	   'reportsworkflowdir=s' => \$reports_workflow_dir,
	   'createreportdirectories!' => \$do_create_report_directories,
	   'automount=s' => \$auto_mount,
	   'autoumount=s' => \$auto_umount,
	   'mirrorurl=s' => \$mirror_url,
	   'mirrorurlct|mirrorurlcpantesters' => sub { $mirror_url = 'http://cpan.cpantesters.org/' },
	   'mirrorurlfunet' => sub { $mirror_url = 'ftp://ftp.funet.fi/pub/CPAN' },
	   'mirrorurlperl'  => sub { $mirror_url = 'http://www.perl.com/CPAN/' },
	   'mirrorurldevelooper' => sub { $mirror_url = 'http://cpan.develooper.com/' },
	   'mirrorurlmetacpan' => sub { $mirror_url = 'https://cpan.metacpan.org/' }, # contains also backpan
	   'mirrorurlfastftp|mirrorurlftpfast' => sub { $mirror_url = 'ftp://ftp.hawo.stw.uni-erlangen.de/CPAN' },
	   'debug!' => \$debug,
	   'pre=s@' => \@pre_dist_or_mods,
	   'cpanconf=s@' => \@cpan_conf,
	   'cpanconfunchecked|cpanconf-unchecked=s@' => \@cpan_conf_unchecked, # XXX I would like to have --cpanconf! instead, but this is not possible with GetOptions
	   'destroyperl!' => \$destroy_perl_in_path,
	   'addthisperlpath!' => \$add_this_perl_path,
	   'as-root' => \$as_root,
	   'efence' => \$efence, # XXX very slow --- it's better to create a distroprefs file where efence operation is enabled only in the tests, and only if CPAN_SMOKE_MODULES_FORCE_FAIL=yes is set
	   'strace=s' => \$strace,
	   'truss=s' => \$truss,
	   'ktrace=s' => \$ktrace,
	   'typescript!' => \$do_typescript,
	   'filemon!' => \$do_filemon,
	   'distroprefs!' => \$use_distroprefs,
	   'prefsdir=s' => \$prefs_dir,
	   'limits!' => \$use_limits,
	   'signalend!' => \$signal_end,
	   'moduleprintused|module-printused!' => \$module_printused,
	   'minbuilddiravail=s' => \$min_build_dir_avail,
	   'minbuilddircleanup=s' => \$min_build_dir_cleanup,
	   'hidemod=s@' => \@hidemod,
	   'timefake=s' => \$time_fake,
	   'vnc!'  => \$use_vncserver,
	   'x11display=s' => \$x11_display,
	   'reloadindex|reload-index' => \$reload_index,
	   'ignorehistory' => \$ignore_history,
	   'deterministichashes!' => \$deterministic_hashes,
	   'randomhashes!' => sub {
	       my $val = $_[1];
	       $deterministic_hashes = !$val;
	   },
	   'hashseed|hash-seed=s' => sub {
	       my $val = $_[1];
	       if ($val =~ m{^(\d+)(?::(n|no|y|ye|yes))?$}i) {
		   $perl_hash_seed = $1;
		   if (defined $2) {
		       if ($2 =~ m{^n}) {
			   $perl_perturb_keys = 'NO';
		       }
		   } else {
		       $perl_perturb_keys = 'NO';
		   }
	       } else {
		   die "--hashseed value is either an 'hashseed' or 'hashseed:no' or 'hashseed:yes' (hashseed being an integer)";
	       }
	   },
	   'mytmpdir=s' => \$my_tmpdir,
	   'failifnothingdone|fail-if-nothing-done!' => \$fail_if_nothing_done,
	   'oldcpanpmhack|old-cpan-pm-hack!' => \$old_cpan_pm_hack, # e.g. for CPAN 1.76_01
	   'sysdeps'              => sub { $sysdeps = 'interactive' },
	   'sysdeps-batch'        => sub { $sysdeps = 'batch' },
	   'no-sysdeps|nosysdeps' => sub { $sysdeps = '' },
	  )
    or die <<EOF;
usage: $0
     [-i|-install] [-shell]
     [-a|-allperls] [-perl /path/to/perl [-perl ...]] [-pv x.y.z,x.y.z,....]
     [-fl|-filelist file]
     [-r|-reverse] [-rr] [-splitdists number]
     [-[no]skiptested] [-[no]report]
     [-mirrorurl ...]
     [-warntimeout secs] [-[no]sqllite]
     [-[no]wait] [-[no]batch]
     [-[no]builddirreuse]
     [-n] [-[no]debug]
     [-pre dist/module [...]]
     [-cpanconf key=value [-cpanconf ...]]
     [-[no]destroyperl]
     [-strace|-truss|-ktrace file] [-[no]typescript] [-filemon]
     [-[no]signalend] [-moduleprintused] [-hidemod A::B ...]
     [-timefake options]
     [-[no]distroprefs] [-prefsdir ...]
     [-[no]limits] [-vnc] [-x11display :...]
     [-minbuilddiravail bytes|...k|...M|...G]
     [-reloadindex]
     [-[no]savereports] [-[no]createreportdirectories]
     [dist ...]

-i: test and install
-reinstall: test and reinstall
-shell: just start the CPAN shell with the special smoker settings

-a: use all installed perls (otherwise some perls will not be used)
-perl path: use the named perl
-pv x.y.z: use the perl named by version number (or use conditions <, >, <=, >=)
-thisperl: use the current perl in PATH (useful for perlbrew)

-pre dist/module: module or distribution which should be tested before all others
-fl file: file with distributions to test

-r:  reverse the list of tested distribution
-rr: reverse just a smaller working set (to be used with -splitdists)
-splitdists number: test at most number distribution within one iteration (default $split_dists)
-skiptested: skip already tested distributions (use ~/.cpanreporter/reports-sent.db list)
-noreport: don't use CPAN::Reporter

-warntimeout secs: warn after inactivity (needs idletermchecker program, default $warntimeout)
-[no]sqllite: (do not) use CPAN::SQLite
-wait: wait at the end of the smoke run
-batch: avoid interactivity by using some defaults (default: $batch)
-forparallelsmoker: runs for a parallel smoker
-builddirreuse: set the corresponding CPAN shell option
-cpanconf key=val: change CPAN configuration variable
-moduleprintused: report used modules using Module::PrintUsed
-unkind:      disable the default to run with low priority
-hidemod: use Devel::Hide to "hide" modules when building. A popular one is
          -hidemod "Test::Pod Test::Pod::Coverage"

-n:  do not do anything, just show what would be done
-debug: enable more debugging
EOF
if ($strace && -e $strace) {
    die "File specified with -strace '$strace' must not exist";
}
if ($truss && -e $truss) {
    die "File specified with -truss '$truss' must not exist";
}
if ($ktrace && -e $ktrace) {
    die "File specified with -ktrace '$ktrace' must not exist";
}
for ($strace, $truss, $ktrace) { # protect the user
    if (defined $_ && m{^-}) {
	die "The -strace/-truss/-ktrace option takes a filename, and '$_' looks like an option!\n";
    }
}
if ($use_vncserver && !is_in_path('vncserver')) {
    die '-vnc specified, but vncserver is not in path';
}

if ($build_dir_reuse && $per_day_build_dir) {
    die "Cannot use -builddirreuse and -perdaybuilddir options together\n";
}

if ($deterministic_hashes && defined $perl_hash_seed) {
    die "Can't use --deterministichashes together with --hashseed";
}
if ($deterministic_hashes) {
    $perl_hash_seed = 0;
}

if ($sysdeps ne '') {
    push @cpan_conf_unchecked, 'plugin_list=CPAN::Plugin::Sysdeps=' . $sysdeps;
}

$SIG{HUP} = sub {
    warn "HUP signal caught, will cleanly stop as fast as possible...\n";
    $stop_signal = 1;
};

xterm_conf('-title', 'Starting cpan_smoke_modules...');

TRY_TYPESCRIPT: {
    if ($do_typescript || !defined $do_typescript) {
	my $no_typescript_sub = sub {
	    my $msg = shift;
	    if ($do_typescript) {
		die "ERROR: $msg";
	    } else {
		warn "INFO: $msg, switch off usage of typescript...\n";
		$do_typescript = 0;
		no warnings 'exiting';
		last TRY_TYPESCRIPT;
	    }
	};

	if ($^O !~ m{^(linux|freebsd|darwin)$}) {
	    $no_typescript_sub->("-typescript implemented only for linux, freebsd, and darwin");
	}
	if (!is_in_path('script')) {
	    $no_typescript_sub->("-typescript specified, but 'script' executable is not in path");
	}
	if ($^O eq 'linux') {
	    if ($do_typescript) {
		require String::ShellQuote;
	    } else {
		eval q{ require String::ShellQuote };
		if ($@) {
		    $no_typescript_sub->($@);
		}
	    }
	}
	# From this point we have all prereqs for typescript operation,
	# everything else is fatal even with $do_typescript=undef
	if (!-d $cpan_smoke_typescripts_dir) {
	    mkdir $cpan_smoke_typescripts_dir
		or die "Can't create $cpan_smoke_typescripts_dir: $!";
	}
	my $now = time;
	my $typescript_day_dir = "$cpan_smoke_typescripts_dir/" . POSIX::strftime("%Y%m%d", localtime $now);
	if (!-d $typescript_day_dir) {
	    mkdir $typescript_day_dir;
	    if (!-d $typescript_day_dir) {
		die "Can't create $typescript_day_dir: $!";
	    }
	}
	$typescript_file = $typescript_day_dir . "/" . POSIX::strftime("%H%M%S", localtime) . ".typescript";

	# At this point typescript operations is really possible
	$do_typescript = 1;
    }
}
if ($do_filemon) {
    if (!$do_typescript) {
	die '-filemon option useless without -typescript';
    }
    if (!-r "/dev/filemon") {
	die <<EOF;
/dev/filemon does not exist. On FreeBSD, you create the device
with

    sudo kldload filemon.ko

Other OS are probably unsupported.
EOF
    }
}

if ($do_action !~ m{^(test|report|install|reinstall|shell)$}) {
    die "Invalid action '$do_action'";
}
my $original_do_action = $do_action;
if ($do_action eq 'reinstall') {
    $do_action = 'test';
    push @post_actions, 'install_tested';
}

my @dist_or_mods = @ARGV;
if ($do_action eq 'shell' && !@dist_or_mods) {
    @dist_or_mods = "This_is_just_a_dummy";
}
if ($fl) {
    open my $fh, $fl
	or die "Cannot open filelist $fl: $!";
    while(<$fh>) {
	chomp;
	push @dist_or_mods, split / /;
    }
}
if (!@dist_or_mods) {
    die "dist or mod?";
}

my @pv_conditions;
if (@pv) {
    my @remaining_pvs;
    for my $pv (@pv) {
	if (my($expr, $value) = $pv =~ m{^([<>]=?)(.*)}) {
	    require version;
	    push @pv_conditions, [$expr, version->new($value)];
	} else {
	    push @remaining_pvs, $pv;
	}
    }
    if (@remaining_pvs) {
	if (@pv_conditions) {
	    die "Mixing conditional perl versions and fixed versions is not supported";
	}
	push @perls, map { "perl$_" } map { split /,/ } @remaining_pvs;
    }
}

if ($do_this_perl) {
    my $perl = is_in_path("perl");
    if ($perl) {
	push @perls, $perl;
    } else {
	die "Strange: cannot find 'perl' in PATH?!";
    }
}

if (!@perls) {
    if ($all_perls) {
	my @all_perl_defs;

	my $system_perl; # if symlinked
	my $system_perl_id; # if hardlinked, then use dev+ino for stat()
	if ($^O eq 'freebsd') {
	    if (-l "/usr/local/bin/perl5") {
		$system_perl = readlink "/usr/local/bin/perl5";
	    } else {
		if (my(@stat) = stat "/usr/local/bin/perl5") {
		    $system_perl_id = join(",", @stat[0,1]);
		}
	    }
	}

	my @candidates;
	if ($^O eq 'MSWin32') {
	    @candidates = ('C:/strawberry/perl/bin/perl.exe', 'C:/Perl/bin/perl.exe');
	} else {
	    @candidates = glob("/usr/local/bin/perl5.*.*");
	}
	# Also add perlbrew perls:
	for my $candidate (glob("$ENV{HOME}/perl5/perlbrew/perls/*/bin/perl5.*.*")) {
	    push @candidates, $candidate;
	}

	my %latest_blead; # type ("", "t") -> version --- make sure that all availables types (debug, threaded, normal) of the latest bleadperls are tested
	my $max_stable_perl_ver;
    CANDIDATE: for my $candidate (@candidates) {
	    next if !-x $candidate;

	    if ($^O eq 'MSWin32') { # special handling because of different naming rules
		push @all_perl_defs, [$candidate, undef];
		next;
	    }

	    my $candidate_id = do {
		if (my @stat = stat $candidate) {
		    join(",", @stat[0,1]);
		} else {
		    undef;
		}
	    };
	    if (
		($system_perl && $candidate eq $system_perl) ||
		($system_perl_id && $candidate_id && $candidate_id eq $system_perl_id)
	       ) {
	    HANDLE_SYSTEM_PERL: {
		    if ($^O eq 'freebsd' && $candidate =~ m{^/usr/local/bin/(.*)$}) {
			my $alternative_perl = "/usr/$1/bin/perl";
			if (-x $alternative_perl) {
			    $candidate = $alternative_perl;
			    last HANDLE_SYSTEM_PERL;
			}
		    }
		    if (_is_install_like_action()) {
			warn "Skip system perl '$candidate' for '$original_do_action' action...\n";
			next CANDIDATE;
		    }
		    if ($skip_system_perl) {
			warn "Skip system perl '$candidate', required by option...\n";
			next CANDIDATE;
		    }
		}
	    }
	    if (my($ver, $minor, $type) = $candidate =~ m{/perl(5\.(\d+)\.\d+)(.*)}) {
		$type ||= "";
		my $safe_ver = safe_version($ver);
		if (@pv_conditions) {
		    for my $pv_condition (@pv_conditions) {
			my($cmp, $other_version) = @$pv_condition;
			my $code = '$safe_ver ' . $cmp . ' $other_version';
			my $cond_ret = eval $code;
			if ($@) {
			    die "'$code' failed: $@";
			}
			next CANDIDATE unless $cond_ret;
		    }
		}
		my $is_devel = $minor % 2 == 1;
		if (!$is_devel) {
		    push @all_perl_defs, [$candidate, $safe_ver];
		    if (!$max_stable_perl_ver || $max_stable_perl_ver < $safe_ver) {
			$max_stable_perl_ver = $safe_ver;
		    }
		} else {
		    if (!$latest_blead{$type} || $latest_blead{$type}->[1] < $safe_ver) {
			$latest_blead{$type} = [$candidate, $safe_ver];
		    }
		}
	    }
	}

	# Test blead only if it's newer than the newest stable perl
	for my $latest_blead_type (sort keys %latest_blead) {
	    if ($max_stable_perl_ver && $max_stable_perl_ver > $latest_blead{$latest_blead_type}->[1]) {
		warn "Don't test $latest_blead{$latest_blead_type}->[0] --- $latest_blead{$latest_blead_type}->[1] < $max_stable_perl_ver...";
	    } else {
		push @all_perl_defs, $latest_blead{$latest_blead_type};
	    }
	}

	# Newest first
	my @all_perls = map { $_->[0] } sort { $b->[1] <=> $a->[1] } @all_perl_defs;

	# -skipperl
	if (@skip_perls) {
	    my %skip_perls = map{($_,1)} @skip_perls;
	    @all_perls = grep { !$skip_perls{$_} } @all_perls;
	}

	print STDERR "INFO: Found perls: @all_perls\n";

	push @perls, @all_perls;
    }
    if (!@perls) {
	die "Please specify a perl version with -pv, a perl binary with -perl, or -a\n";
    }
}

{
    my @new_perls;
    for my $perl (@perls) {
	if (-d $perl) {
	    $perl = "$perl/bin/perl"; # directory specified, guess on perl executable
	}
	if (!is_in_path($perl)) {
	    warn "*** WARNING: $perl is not available, removing from list...\n";
	} else {
	    push @new_perls, $perl;
	}
    }
    @perls = @new_perls;
    if (!@perls) {
	die "*** ERROR: Could not find any requested perl.\n";
    }
}
if ($perlr) {
    @perls = reverse @perls;
}

CPAN::HandleConfig->load;
my $prefs_dir_is_changed;
if ($prefs_dir) {
    $prefs_dir_is_changed = 1;
} else {
    $prefs_dir = $CPAN::Config->{prefs_dir};
}

for (@dist_or_mods, @pre_dist_or_mods) {
    # to make it easy to copy'n'paste download URLs from a CPAN http mirror:
    s{^https?://.*/authors/id/./../}{};
    # resolve partial matrix URLs like Module-Runtime+0.014
    s{^(.*)\+(v?\d.*)}{$1-$2};
}

# And allow also partial distribution names without author name
# and even without version.
#
# Also resolve all module names into distributions if -skiptested* is
# used.
TRY_PARTIAL_RESOLVE: {
    my %partial_v_to_full; # partial with version: Foo-Bar-1.23 -> AUTHOR/Foo-Bar-1.23.tar.gz
    my %partial_to_full;   # partial w/o version:  Foo-Bar      -> AUTHOR/Foo-Bar-1.23.tar.gz
    my %duplicates_v; # duplicates for partial with version
    my %duplicates;   # duplicates for partial w/o version
    for my $dist_or_mod (@dist_or_mods) {
	next if $dist_or_mod =~ m{/}; # already an appropriate distname
	my($distvname) = $dist_or_mod =~ m{^(.*-.*)(?:\.(?:tar\.gz|tar.bz2|zip))?$}; # looks like a partial distribution name
	if (!defined $distvname && $skip_tested) {
	    # otherwise: a distname without a dash; should be translated in -skiptested* module
	    $distvname = $dist_or_mod;
	}
	if (defined $distvname) {
	    # note that $distvname may be a dist name without version,
	    # too, so it's somewhat of a misnomer
	    if (!keys %partial_v_to_full) {
		if (!eval {
		    my $packages_file = $CPAN::Config->{keep_source_where} . "/modules/02packages.details.txt.gz";
		    require CPAN::DistnameInfo;
		    my $FH;
		    if (!eval {
			require PerlIO::gzip;
			open $FH, "<:gzip", $packages_file
			    or die "Can't open $packages_file: $!";
		    }) {
			require IO::Zlib;
			$FH = IO::Zlib->new;
			$FH->open($packages_file, "rb")
			    or die "Can't open $packages_file: $!";
		    }
		    my $state = "h";
		    while(<$FH>) {
			if ($state eq 'h') {
			    if (/^$/) {
				$state = 'b';
			    }
			} else {
			    my(undef,undef, $dist) = split;
			    my $d = CPAN::DistnameInfo->new($dist);
			    my $filename = $d->filename;
			    if (defined $filename) {
				my $this_distvname = $d->distvname;
				my $this_dist = $d->dist;
				my $full_distname = $d->cpanid . "/" . $filename;
				if (defined $this_distvname) {
				    if (exists $partial_v_to_full{$this_distvname} && $partial_v_to_full{$this_distvname} ne $full_distname) {
					$duplicates_v{$this_distvname}++;
				    } else {
					$partial_v_to_full{$this_distvname} = $full_distname;
				    }
				}
				if (defined $this_dist) {
				    if (exists $partial_to_full{$this_dist} && $partial_to_full{$this_dist} ne $full_distname) {
					if (!$duplicates{$this_dist}) {
					    $duplicates{$this_dist} = [ $partial_to_full{$this_dist} ]; # initialize with old finding
					}
					push @{ $duplicates{$this_dist} }, $full_distname;
				    } else {
					$partial_to_full{$this_dist} = $full_distname;
				    }
				}
			    }
			}
		    }
		    1;
		}) {
		    warn $@;
		}
            }
	    if (!keys %partial_v_to_full) {
		warn "WARN: Can't resolve any partial distribution names.";
		last TRY_PARTIAL_RESOLVE;
	    }
	    if ($duplicates_v{$distvname}) {
		warn "WARN: Found duplicate for $distvname, cannot resolve...";
	    } elsif (exists $partial_v_to_full{$distvname}) {
		warn "INFO: Resolve partial distname $dist_or_mod -> $partial_v_to_full{$distvname}\n";
		$dist_or_mod = $partial_v_to_full{$distvname};
	    } elsif (@{ $duplicates{$distvname} || [] }) {
		my %unique_duplicates = map {($_,1)} @{ $duplicates{$distvname} };
		warn "INFO: Found multiples for $distvname (" . join(" ", sort keys %unique_duplicates) . ")\n";
		$dist_or_mod =
		    (map { $_->[1] }
		     sort { $b->[0] <=> $a->[0] }
		     map {
			 my $fulldist = $_;
			 my $d = CPAN::DistnameInfo->new($fulldist);
			[safe_version($d->version), $fulldist];
		     } @{ $duplicates{$distvname} })[0];
		warn "INFO: choosing latest: $dist_or_mod\n";
	    } elsif (exists $partial_to_full{$distvname}) {
		warn "INFO: Resolve partial distname $dist_or_mod -> $partial_to_full{$distvname}\n";
		$dist_or_mod = $partial_to_full{$distvname};
	    } else {
		warn "WARN: Can't resolve the partial distribution name $distvname";
	    }
        }
    }
}

{
    my @new_dist_or_mods;
    my %seen_dist_maturity;
    my %seen_dist_released;
    my %seen_mod;
    for my $dist_or_mod (@dist_or_mods) {
	my $d_info = CPAN::DistnameInfo->new($dist_or_mod);
	if (!$d_info || !$d_info->dist) {
	    # It's a module
	    if ($seen_mod{$dist_or_mod}) {
		warn "Remove " . $dist_or_mod . " from list...\n";
	    } else {
		push @new_dist_or_mods, $dist_or_mod;
		$seen_mod{$dist_or_mod}++;
	    }
	} else {
	    my $cpanid = $d_info->cpanid;
	    if (!$cpanid) {
		# assume "short" distname
		($cpanid) = $dist_or_mod =~ m{([^/]+)};
	    }
	    my($dist, $maturity) = ($d_info->dist, $d_info->maturity);
	    if ($dist && $dist =~ m{/Bundle-Everything-}) { # XXX why it doesn't work through distroprefs?
		warn "Remove 'Bundle-Everything' from list...\n";
		next;
	    }
	    my $dist_maturity_key = "$dist/$maturity";
	    if (!$d_info->dist) { # it's probably a mod name
		push @new_dist_or_mods, $dist_or_mod;
	    } elsif ($seen_dist_maturity{$dist_maturity_key}) {
		warn "Remove " . $d_info->distvname . " (maturity=$maturity) from list...\n";
	    } elsif ($maturity eq 'developer' && $seen_dist_released{$dist}) {
		warn "Remove " . $d_info->distvname . " from list (younger _released_ version exists)...\n";
	    } else {
		push @new_dist_or_mods, $dist_or_mod;
		$seen_dist_maturity{$dist_maturity_key}++;
		if ($d_info->maturity eq 'released') {
		    $seen_dist_released{$dist}++;
		}
	    }
	}
    }
    @dist_or_mods = @new_dist_or_mods;
}

if (!@dist_or_mods) {
    warn "No distributions to $original_do_action.\n";
    exit 0;
}

if ($r) {
    @dist_or_mods = reverse @dist_or_mods;
}

my $has_private_tmpdir;
if ($my_tmpdir) {
    if (!-d $my_tmpdir) {
	die "The defined temporary directory '$my_tmpdir' does not exist";
    } else {
	$ENV{TMPDIR} = $my_tmpdir;
	# don't set $has_private_tmpdir here
    }
} else {
    my @tmpdir_defs = (
		       # Directory      User-owned	Do a noexec check?
		       (defined $ENV{XDG_RUNTIME_DIR} ? [$ENV{XDG_RUNTIME_DIR}, 1, 1] : ()),
		       ['/var/tmp',     0,             0],
		       ['/tmp',         0,             0],
		      );
    for my $another_tmp_def (@tmpdir_defs) {
	my($another_tmp, $user_owned, $do_noexec_check) = @$another_tmp_def;
	if (-d $another_tmp && -w $another_tmp) {
	    if ($do_noexec_check) {
		next if $^O ne 'linux';
		next if !eval q{ require Filesys::Statvfs; 1 };
		my $ST_NOEXEC = 8; # XXX where to get this flag?
		my @flags = Filesys::Statvfs::statvfs($another_tmp);
		next if !defined $flags[8]; # something failed
		next if $flags[8] & $ST_NOEXEC;
		# may use it...
	    }
	    my $_another_tmp = $another_tmp . '/cpansmoker' . (!$user_owned ? "-$<" : '');
	    if (!-d $_another_tmp) {
		mkdir $_another_tmp
		    or die "Cannot create $_another_tmp: $!";
		if (!$user_owned) {
		    chmod 01777, $_another_tmp
			or die "Cannot set sticky bit: $!";
		}
	    }

	    if ($per_day_build_dir) {
		$_another_tmp .= '/' . per_day_directory_name();
		if (!-d $_another_tmp) {
		    mkdir $_another_tmp
			or die "Cannot create $_another_tmp: $!";
		}
	    }

	    $ENV{TMPDIR} = $_another_tmp;
	    $has_private_tmpdir = 1;
	    last;
	}
    }
}

if ((   $n                    # no idletermchecker in no exec mode:
     || !$ENV{DISPLAY}        # no idletermchecker if there's no DISPLAY
     || $do_action eq 'shell'
     || $^O eq 'darwin'       # idletermchecker causes too much flicker on Macs
    ) && $warntimeout) {
    $warntimeout = undef;
}

if ($save_reports) {
    if (!$for_parallel_smoker && $^O ne 'MSWin32') { # parallel smoker already have a correct cpanreporter config, and so have the windows' perls
	my($tmpfh,$tmpfile) = predictable_tempfile();
	if (!defined $tmpfh) {
	    ($tmpfh,$tmpfile) = tempfile(SUFFIX => "_config.ini", UNLINK => 1)
		or die "Can't create tempfile: $!";
	}
	my $config_ini_path = "$ENV{HOME}/.cpanreporter/config.ini";
	open my $ifh, "<", $config_ini_path
	    or die "Can't open $config_ini_path: $!";

	if (!$reports_workflow_dir) {
	    # use default
	    $reports_workflow_dir = $reports_workflow_default_dir;
	    if (!-d $reports_workflow_dir && !-l $reports_workflow_dir) {
		mkpath $reports_workflow_dir;
	    }
	    if (!-d $reports_workflow_dir) {
		# automounted? force mounting?
		opendir my($dir), $reports_workflow_dir;
	    }
	    if (!-d $reports_workflow_dir) {
		die "Cannot create $reports_workflow_dir";
	    }
	} else {
	    # use supplied directory --- it's assumed that it already
	    # exists and won't be created here
	    if (!-d $reports_workflow_dir) {
		die "The directory $reports_workflow_dir does not exist";
	    } # the subdirs may be missing and will be created
	}
	my $new_reports_dir = "$reports_workflow_dir/new";

	if (!-d $new_reports_dir && defined $auto_mount) {
	    warn "INFO: Run '$auto_mount'...\n";
	    system $auto_mount;
	    if ($? != 0) {
		die "ERROR: Running '$auto_mount' failed";
	    }
	    $need_auto_umount = 1;
	}

	my $changed_transport = 0;
	my $new_transport_setting = "transport=File $new_reports_dir\n";
	while(<$ifh>) {
	    if (/^transport\s*=/) {
		print $tmpfh $new_transport_setting;
		$changed_transport++;
	    } elsif (/^edit_report\s*=/) {
		print $tmpfh "edit_report=default:no\n";
	    } elsif (/^cc_author\s*=/) {
		# skip
	    } elsif (/^send_report\s*=/) {
		print $tmpfh "send_report=default:yes\n";
	    } else {
		print $tmpfh $_;
	    }
	}
	if (!$changed_transport) {
	    print $tmpfh $new_transport_setting;
	    $changed_transport++;
	}
	close $tmpfh
	    or die "Error while closing: $!";

	for my $dir ($new_reports_dir,
		     "$reports_workflow_dir/sync",
		     "$reports_workflow_dir/process",
		     "$reports_workflow_dir/done",
		     "$reports_workflow_dir/undecided",
		    ) {
	    if (!-d $dir) {
		if ($do_create_report_directories) {
		    mkdir $dir
			or do {
			    my $err = $!;
			    if (!-d $dir) {
				die "Can't create directory $dir: $err";
			    }
			};
		} else {
		    die <<EOF;
ERROR: directory '$dir' is missing and
--nocreatereportdirectories is specified.
Please fix the situation manually, e.g. by
mounting or manually creating the required directories.
EOF
		}
	    }
	}
	$ENV{PERL_CPAN_REPORTER_CONFIG} = $tmpfile;
	push @touch_files, $tmpfile;
    }
}

(my $short_hostname = hostname) =~ s{\..*}{};
chomp(my $tty = `tty`);
(my $short_tty = $tty) =~ s{^.*/}{};

my $idletermchecker_pid;
my @idletermchecker_cmd;
if ($warntimeout) {
    if (is_in_path("idletermchecker")) {
	if ($tty) {
	    if (is_in_path('pistachio-perl')) {
		# If pistachio-perl exists then use it, because it has
		# Tk available, this is not necessarily the case for
		# the system perl
		@idletermchecker_cmd = ('pistachio-perl', '-S', 'idletermchecker');
	    } else {
		@idletermchecker_cmd = ('idletermchecker');
	    }
	    $idletermchecker_pid = fork;
	    if ($idletermchecker_pid == 0) {
		exec @idletermchecker_cmd, "-tk", "-with-hostname", "-s", "-timeout", $warntimeout, "-timeout2", $warntimeout+60, "-q", $tty;
		die $!;
	    }
	} else {
	    print STDERR "NOTE: cannot get tty, idletermchecker will not run.\n";
	}
    } else {
	print STDERR "NOTE: idletermchecker is not available.\n";
    }
}

# neither "nice" on Windows, nor setpriority or so:
if (!$unkind && $^O eq 'MSWin32') {
    eval {
	require Win32::Process;
	Win32::Process::Open(my $proc, $$, 0)
		or die($^E);
	$proc->SetPriorityClass(Win32::Process::IDLE_PRIORITY_CLASS())
	    or die($^E);
    };
    warn $@ if $@;
}

open my $logfh, ">>", $cpan_smoke_log
    or warn "WARNING: Cannot write to logfile $cpan_smoke_log: $!";
$logfh->autoflush(1);

if ($ignore_history) {
    my $empty_config_dir = tempdir("CPAN_Reporter_config_XXXXXXXX", TMPDIR => 1, CLEANUP => 1);
    $ENV{PERL_CPAN_REPORTER_DIR} = $empty_config_dir;
}

my $path_with_destroy_perl;
if ($destroy_perl_in_path) {
    if ($^O eq 'MSWin32') {
	die "-destroyperl is not supported with Windows";
    }
    require File::Temp;
    my($tempdir) = File::Temp::tempdir(TMPDIR => 1, CLEANUP => 1);
    my $perlbin = "$tempdir/perl";
    open my $ofh, ">> $perlbin" or die "Cannot write to $perlbin: $!";
    print $ofh <<'EOF' or die $!;
#! /bin/sh
echo '# Please use $^X instead of perl in system()'
echo '# and similar calls.'
echo '#'
echo '# See also the $EXECUTABLE_NAME or $^X entry'
echo '# in the perlvar.pod documentation.'
echo '#'
exit 1
EOF
    close $ofh
	or die $!;
    chmod 0755, $perlbin
	or die $!;
    $path_with_destroy_perl = $tempdir;
}

my $PERL_CPAN_REPORTER_DIR;
$PERL_CPAN_REPORTER_DIR = $ENV{PERL_CPAN_REPORTER_DIR} if $ENV{PERL_CPAN_REPORTER_DIR};

my $effective_x11_display;
if ($use_vncserver) {
    if (!$x11_display) {
	$x11_display = find_free_x11_display();
    }
    my @cmd = ('vncserver', $x11_display, '-localhost', '-nolisten', 'tcp');
    warn "INFO: starting vncserver on display $x11_display...\n";
    system @cmd;
    if ($? != 0) {
	die "ERROR: Failure running '@cmd'";
    }
    my $try_x11_display = $x11_display;
    # Do a double check if it's working
    if (is_in_path('xset')) { # hopefully everywhere installed...
	system "xset -display $try_x11_display q >/dev/null 2>&1";
	if ($? != 0) {
	    die "ERROR: X11 display check using 'xset -display $try_x11_display' failed, refuse to continue...\n";
	}
    }
    $effective_x11_display = $try_x11_display;
}

maybe_pause();

my $last_xterm_title;
LOOP_PERLS: for my $perl (@perls) {
    print STDERR "#"x70,"\n";
    print STDERR "# $perl\n";

    if (0) {
	# not active anymore --- currently there are no broken
	# CPAN.pm's around
	if (is_CPAN_pm_broken($perl)) {
	    warn <<EOF;
**********************************************************************
* Broken CPAN::PERL5LIB causing endless loops --- skipping $perl!
**********************************************************************
EOF
	    next;
	}
    }
	    
    my $split_dists = $split_dists;
    if ($do_action eq 'shell') {
	$split_dists = 0;
    }

    my @dist_or_mods = @dist_or_mods;

    # Set PERL_CPAN_REPORTER_DIR if $prefix/.cpanreporterdir file exists
    local %ENV = %ENV; # local $ENV{PERL_CPAN_REPORTER_DIR} and a later local %ENV = %ENV seems to trigger a perl bug...
    if ($PERL_CPAN_REPORTER_DIR) {
	$ENV{PERL_CPAN_REPORTER_DIR} = $PERL_CPAN_REPORTER_DIR;
    } else {
	my $perl_prefix = `$perl -MConfig -e 'print \$Config{prefix}'`;
	if ($perl_prefix && open my $fh, "$perl_prefix/.cpanreporterdir") {
	    chomp(my $reporter_dir = <$fh>);
	    if ($reporter_dir) {
		if (!-d $reporter_dir) {
		    warn "Specified reporter dir <$reporter_dir> does not exist, cannot use...";
		} else {
		    warn "Using .cpanreporter directory $reporter_dir...\n";
		    $ENV{PERL_CPAN_REPORTER_DIR} = $reporter_dir;
		}
	    }
	}
    }

    # check if reports-sent.db may be written to
    my $reports_sent_db_file;
    {
	my $cpan_reporter_dir = $ENV{PERL_CPAN_REPORTER_DIR} || "$ENV{HOME}/.cpanreporter";
	$reports_sent_db_file = "$cpan_reporter_dir/reports-sent.db";
	if (-e $reports_sent_db_file && !-w $reports_sent_db_file) {
	    die "Cannot write to $reports_sent_db_file";
	}
    }

    if ($skip_tested) {
	my($thisperl, $thisperlver, $thispatch, $thisarchname, $thisosvers, $thisarch);
	{
	    my $perl_info_line;
	    open my $fh, '-|', $perl, '-MConfig', '-e',
		'print join("\t", $Config{version}, $Config{perl_patchlevel}, $Config{archname}, $Config{osvers})'
		or die "Can't run $perl -MConfig ...: $!";
	    $perl_info_line = <$fh>;
	    ($thisperlver, $thispatch, $thisarchname, $thisosvers) = split /\t/, $perl_info_line;
	    $thisperl = "perl-$thisperlver";
	    if ($thispatch) {
		$thisperl .= " patch $thispatch";
	    }
	    $thisarch = $thisarchname . ' ' . $thisosvers;
	}

	my @new_dist_or_mods;
	if ($use_reports_sent_cache_file) {
	    if (!$reports_sent_cache_pl_called++) {
		# Calling this once per cpan_smoke_modules run should be sufficient
		# --- theoretically other cpan_smoke_modules may cause changes here
		# but for the usual case (we check only for one or few specific
		# dists) this should not matter.
		my @cmd = ($^X, '-S', 'reports-sent-cache.pl', '--reports-sent', $reports_sent_db_file);
		system @cmd;
		if ($? != 0) {
		    die "Running @cmd failed";
		}
	    }
	    my $reports_sent_cache_file = $reports_sent_db_file . '.cache';
	    require MLDBM;
	    require DB_File;
	    require Storable;
	    require Fcntl;
	    no warnings 'once';
	    local $MLDBM::UseDB = 'DB_File';
	    local $MLDBM::Serializer = 'Storable';
	    my $lockfh;
	    my $tie_flags = 0;
	    if (!-e $reports_sent_cache_file) {
		warn "WARN: $reports_sent_cache_file does not exist --- is this a first-time run?\n";
		$tie_flags |= &Fcntl::O_CREAT;
	    } else {
		warn "INFO: About to lock $reports_sent_cache_file...\n";
		open $lockfh, '<', $reports_sent_cache_file
		    or die $!;
		flock $lockfh, &Fcntl::LOCK_SH
		    or die "Can't lock $reports_sent_cache_file: $!";
	    }
	    warn "INFO: About to tie $reports_sent_cache_file...\n";
	    tie my %cache, 'MLDBM', $reports_sent_cache_file, &Fcntl::O_RDONLY|$tie_flags, 0
		or die "Can't tie $reports_sent_cache_file: $!";
	    for my $dist (@dist_or_mods) {
		my $d = CPAN::DistnameInfo->new($dist);
		my $has_entries = eval { $cache{$d->distvname}->{$thisperlver}->{$thisarchname} };
		if ($has_entries) {
		    if (!$skip_tested_fail && !$skip_tested_pass) {
			warn "Skipping already tested $dist\n" if $debug;
			next;
		    } elsif ($skip_tested_fail && $skip_tested_pass) {
			# only skip if neither fail nor pass happened
			if ($has_entries->{PASS} && $has_entries->{FAIL}) {
			    warn "Skipping already tested $dist (both FAIL and PASS seen)\n" if $debug;
			    next;
			}
		    } elsif ($skip_tested_fail && $has_entries->{FAIL}) {
			warn "Skipping already tested $dist (FAIL seen)\n" if $debug;
			next;
		    } elsif ($skip_tested_pass && $has_entries->{PASS}) {
			warn "Skipping already tested $dist (PASS seen)\n" if $debug;
			next;
		    }
		}
		push @new_dist_or_mods, $dist;
	    }
	} else {
	    warn "About to parse sent reports...\n";
	    my %stdopts = (skiptestedfail => $skip_tested_fail, skiptestedpass => $skip_tested_pass);
	    if (@perls == 1) {
		# optimization: just parse results for this perl only
		parse_reports_sent(onlyperl => $thisperl, onlyarch => $thisarch, %stdopts);
	    } else {
		parse_reports_sent(%stdopts);
	    }

	    for my $dist (@dist_or_mods) {
		my $d = CPAN::DistnameInfo->new($dist);
		no warnings 'uninitialized'; # undefs may happen in $author and $distname if it's a mod, not a dist
		if (my $old_d = $dists->{$d->dist}->{$thisperl}->{$thisarch}) {
		    if (safe_version($d->version) > safe_version($old_d->{dist}->version)) {
			push @new_dist_or_mods, $dist;
		    } elsif ($debug) {
			warn "Skipping already tested $dist\n";
		    }
		} else {
		    push @new_dist_or_mods, $dist;
		}
	    }
	}
	@dist_or_mods = @new_dist_or_mods;

	if (!@dist_or_mods) {
	    warn "All dists already tested, skipping this perl...\n";
	}
    }

    if ($original_do_action eq 'reinstall') {
	# reinstall is only supported for already installed modules.
	# Modules not installed will be filtered out. It's also not
	# possible to specify distributions.
	open my $fh, '-|', $perl, '-MCPAN', '-e', <<'EOF', @dist_or_mods or die $!;
use strict;
for my $mod (@ARGV) {
    my $inst_file = eval { CPAN::Shell->expand("Module", $mod)->inst_file };
    if ($inst_file) {
	print $mod, "\n";
    }
}
EOF
	my %mod_installed;
	while(<$fh>) {
	    chomp;
	    $mod_installed{$_} = 1;
	}
	@dist_or_mods = grep { $mod_installed{$_} } @dist_or_mods;
	if (!@dist_or_mods) {
	    warn "No modules to reinstall, skipping this perl...\n";
	}
    }

    my $total_dists = scalar(@dist_or_mods) + scalar(@pre_dist_or_mods);
    my $dist_i = 0;

    while (@dist_or_mods) {
	my @work_set;
	if (!$split_dists) {
	    @work_set = @dist_or_mods;
	    @dist_or_mods = ();
	} else {
	    my $i = $split_dists;
	    while(@dist_or_mods && $i > 0) {
		push @work_set, shift @dist_or_mods;
		$i--;
	    }
	    if ($rr) {
		@work_set = reverse @work_set;
	    }
	}
	
	my $log_preamble = "$perl: $work_set[0] .. $work_set[-1]";
	if ($logfh) {
	    print $logfh "[" . scalar(localtime) . "] $log_preamble BEGIN\n";
	}
	my $std_title = POSIX::strftime("%H:%M", gmtime) . " ";
	$std_title .= "smoke($short_hostname:$short_tty): $perl";
	xterm_conf('-title', $std_title);

	if ($use_distroprefs && $prefs_dir && -d $prefs_dir && -r "$prefs_dir/SlayMakefile") {
	    if (is_in_path("slaymake")) {
		save_pwd {
		    if (chdir $prefs_dir) {
			my @cmd = qw(slaymake);
			while () {
			    system(@cmd);
			    if ($? != 0) {
				warn qq{Error while executing <@cmd>.
Please fix and retry with <RETURN>: "};
				<STDIN>;
			    } else {
				last;
			    }
			}
		    }
		};
	    } else {
		warn <<EOF;
**********************************************************************
* WARNING
* SlayMakefile exists in $prefs_dir, but slaymake is not available.
* Please install Slay::Maker from CPAN.
* Proceeding without validating and updating distroprefs.
**********************************************************************
EOF
	    }
	}

	my $cpan_shell_init = "";
	$cpan_shell_init .= q#{ package CPAN::SRTShell; @ISA = $CPAN::Frontend; sub mysleep { shift; sleep shift()/10 }} $CPAN::Frontend="CPAN::SRTShell";#;
	if ($old_cpan_pm_hack) {
	    $cpan_shell_init .= q#CPAN::Config->load; #; # 1.76_01 does not have CPAN::HandleConfig
	} else {
	    $cpan_shell_init .= q#CPAN::HandleConfig->load; #;
	}
	if ($^O ne 'MSWin32') { # somehow does not work under Windows
	    $cpan_shell_init .= q{$CPAN::VERSION >= 1.9205 or warn(("*"x70)."\n*** Old CPAN version $CPAN::VERSION\n".("*"x70)."\n"); };
	}
	if ($do_report) {
	    $cpan_shell_init .= q{$CPAN::Config->{test_report}=1; };
	} else {
	    $cpan_shell_init .= q{$CPAN::Config->{test_report}=0; };
	}
	$cpan_shell_init .= q{$CPAN::Config->{urllist}=[qw(} . $mirror_url . q{)]; };
	$cpan_shell_init .= q{$CPAN::FTP::connect_to_internet_ok=1; };
	# The new feature seems to be problematic:
	$cpan_shell_init .= q{$CPAN::Config->{threshold_perl5lib_upto} = 9999999; };
	if (!$use_distroprefs) {
	    $cpan_shell_init .= q{$CPAN::Config->{prefs_dir} = ""; };
	} elsif ($prefs_dir_is_changed) {
	    $cpan_shell_init .= q{$CPAN::Config->{prefs_dir} = "} . $prefs_dir . q{"; };
	}
	$cpan_shell_init .= q{eval { require Expect; 1 } or $ENV{PERL_EXTUTILS_AUTOINSTALL}=q{--defaultdeps}; };
	if ($use_sqlite) {
	    $cpan_shell_init .= q#if (eval { require CPAN::SQLite; 1; }) { $CPAN::Config->{use_sqlite}=1; } else { $CPAN::Config->{cache_metadata}=1; } #;
	} else {
	    $cpan_shell_init .= q#$CPAN::Config->{use_sqlite}=0; $CPAN::Config->{cache_metadata}=1; #;
	}
	$cpan_shell_init .= q#$CPAN::Config->{prerequisites_policy} = q[follow]; #;
	if ($batch) {
	    $cpan_shell_init .= q#$CPAN::Config->{build_requires_install_policy} =~ s{ask/}{}; #; # don't be interactive
	}
	if ($do_action eq 'shell') {
	    $cpan_shell_init .= q#$CPAN::Config->{scan_cache} = q[never]; #;
	}

	# perl belongs to this user -> no sudo necessary
	my $need_sudo_keeper;
	if (_is_install_like_action() || $do_action eq 'shell') {
	    my $perl_fullpath = is_in_path($perl);
	    my $perl_uid = (stat($perl_fullpath))[4];
	    if ($perl_uid == $<) {
		$cpan_shell_init .= q#$CPAN::Config->{make_install_make_command}=q{make}; $CPAN::Config->{mbuild_install_build_command}=q{./Build}; #;
	    }
	    if ($perl_uid != $< && _is_install_like_action() && $use_sudo_keeper) {
		if (is_in_path('sudo_keeper')) {
		    $need_sudo_keeper = 1;
		} else {
		    warn "sudo operation necessary, but no sudo_keeper program available...\n";
		}
	    }
	}
	
	if ($build_dir_reuse) {
	    my $build_reuse_dir = "build_reuse_$perl";
	    $build_reuse_dir =~ s{/}{_}g;
	    $build_reuse_dir = "/usr/local/src/CPAN/$build_reuse_dir";
	    mkdir $build_reuse_dir if !-d $build_reuse_dir;
	    die "Cannot use $build_reuse_dir" if !-d $build_reuse_dir || !-w $build_reuse_dir;
	    $cpan_shell_init .= q{$CPAN::Config->{build_dir_reuse} = 1; $CPAN::Config->{build_dir} = "}.$build_reuse_dir.q{"; };
	} else {
	    $cpan_shell_init .= q{$CPAN::Config->{build_dir_reuse} = 0; };
	}

	if ($per_day_build_dir) {
	    my $today = per_day_directory_name();
	    $cpan_shell_init .= q{$CPAN::Config->{build_dir} .= "/} . $today . q{"; mkdir $CPAN::Config->{build_dir}; }; # let CPAN fail if mkdir was not successful
	}

	if ($debug) {
	    $cpan_shell_init .= q#use Data::Dumper; warn Dumper $CPAN::Config; #;
	}

	if ($reload_index) {
	    $cpan_shell_init .= q{CPAN::Index->force_reload(); };
	}

	for my $def (
		     [\@cpan_conf,           1],
		     [\@cpan_conf_unchecked, 0],
		    ) {
	    my($cpan_conf_ref, $checked) = @$def;
	    for my $cpan_conf (@$cpan_conf_ref) {
		my($key,$val) = split /=/, $cpan_conf, 2;
		if (!defined $key || !defined $val) {
		    die "Probably invalid cpan_conf value '$cpan_conf'";
		}
		if ($checked && !exists $CPAN::Config->{$key}) {
		    die "cpanconf key '$key' is probably invalid --- or use --cpanconf-unchecked instead\n";
		}
		if ($key =~ m{list$}) { # special handling for array
		    if (!length $val) {
			$cpan_shell_init .= q#$CPAN::Config->{# . $key . q#} = []; #;
		    } else {
			$cpan_shell_init .= q#$CPAN::Config->{# . $key . q#} = [q[# . $val . q#]]; #;
		    }
		} else {
		    $cpan_shell_init .= q#$CPAN::Config->{# . $key . q#} = q[# . $val . q#]; #;
		}
	    }
	}

	if ($hack_checksum_check_file) { # hack: try to suppress the "... the checksum has not yet been calculated" prompt
	    $cpan_shell_init .= q#{ my $orig_check_file = \&CPAN::Distribution::CHECKSUM_check_file; *CPAN::Distribution::CHECKSUM_check_file = sub { my($self,$file)=@_; $orig_check_file->($self,$file,1) }; } #;
	}
	if ($hack_skip_distropref_validation) { # hack: my distroprefs files are usually already validated, so don't redo this here
	    $cpan_shell_init .= q#*CPAN::Distribution::_validate_distropref = sub {}; #;
	}

	my @cmd = ($perl);
 	if ($perl =~ /5\.6\.2/ || $perl =~ /5\.005/) {
	    # Preload to avoid segfaults
	    push @cmd, "-MFile::HomeDir";
 	}
	push @cmd, ("-MCPAN", "-e");
	if ($do_action eq 'shell') {
	    push @cmd, $cpan_shell_init . $do_action;
	} else {
	    if ($has_xterm_conf) {
		my $dist_or_mods_line = "";
		for my $dist (@pre_dist_or_mods, @work_set) {
		    my $pc = "";
		    if ($total_dists > 1) {
			$pc = int($dist_i*100/$total_dists)."%";
		    }
		    $dist_or_mods_line .= qq{system(q{env PERL5OPT= xterm-conf -force -title "$std_title $dist $pc"}); \$0 = "\$^X (CPAN.pm $do_action $dist)"; $do_action(qq{$dist}); };
		    $last_xterm_title = "$std_title $dist";
		    $dist_i++;
		}
		push @cmd, $cpan_shell_init . $dist_or_mods_line;
	    } else {
		my $dist_or_mods_line = join(", ", map { qq{qq{$_}} } @pre_dist_or_mods, @work_set);
		push @cmd, $cpan_shell_init . $do_action.qq{($dist_or_mods_line)};
	    }
	}
	for my $post_action (@post_actions) {
	    $cmd[-1] .= qq{$post_action; };
	}

	# Electric Fence is expensive, so run it directly before the
	# CPAN command
	if ($efence) {
	    unshift @cmd, 'ef.sh';
	}

	if ($as_root) {
	    unshift @cmd, 'sudo', '-E';
	}

	if ($strace) {
	    unshift @cmd, 'strace', '-tt', '-f', '-o', $strace;
	}
	if ($truss) {
	    unshift @cmd, 'truss', '-d', '-f', '-o', $truss, '-a', '-e';
	}
	if ($ktrace) {
	    unshift @cmd, 'ktrace', '-id', '-f', $ktrace;
	}

	if (!$unkind && is_in_path("nice") && $^O ne 'MSWin32') {
	    unshift @cmd, "nice";
	}

	if (!$unkind && $^O eq 'linux' && is_in_path('ionice')) {
	    unshift @cmd, 'ionice', '-c2', '-n6';
	}

	my $use_limits = $use_limits;
	if ($short_hostname eq 'eserte' && $perl =~ /t$/) {
	    # XXX Many modules fail with Out of memory on eserte.dev4...
	    # maybe the machine has to much memory (32GB) and therefore
	    # the threading libraries reserves more memory?
	    warn "INFO: turning off -limits on this host for perl=$perl...\n";
	    $use_limits = 0;
	}
	if ($use_limits) {
	    my $data_limit = 1024*1024*1024;
	    my $cputime_limit = 3600*1;
	    my $openfiles_limit = 2048; # the freebsd default is at 22500
	    if (is_in_path("limits") && $^O ne 'MSWin32') {
		# on my FreeBSD system, kern.maxfiles is ~ 12000
		# -v is needed for FreeBSD 7.x
		unshift @cmd, "limits", "-t", $cputime_limit, "-d", $data_limit, "-v", $data_limit, "-n", $openfiles_limit;
	    } elsif (eval { require BSD::Resource; 1 }) {
		# Note that limiting in THIS process is not what is
		# "correct", but resource limits are inherited by the
		# forked processes and such a large data limit is enough
		# for the wrapper process, so it works.
		#
		my $set_limit_if_higher = sub {
		    my($limit, $value, $label) = @_;
		    my $old_limit = BSD::Resource::getrlimit($limit);
		    if (!defined $old_limit || $old_limit == -1) {
			if (!BSD::Resource::setrlimit($limit, $value, $value)) {
			    warn "*** WARNING: Could not set resource limit of $label to $value.\n";
			}
		    }
		};
		# linux does not honor RLIMIT_DATA, but RLIMIT_AS
		$set_limit_if_higher->(BSD::Resource::RLIMIT_AS(), $data_limit);
		$set_limit_if_higher->(BSD::Resource::RLIMIT_CPU(), $cputime_limit);
		$set_limit_if_higher->(BSD::Resource::RLIMIT_NOFILE(), $openfiles_limit);
	    } else {
		warn <<EOF;
*** WARNING: Neither limits(1) nor BSD::Resource available, resource limits
             cannot be set.
EOF
	    }
	}

	# XXX better solution!
	if ($need_sudo_keeper && @hidemod) {
	    warn "WARN: -hidemod conflicts with sudo_keeper.\n";
	    $need_sudo_keeper = 0;
	}

	if ($need_sudo_keeper) {
	    unshift @cmd, 'sudo_keeper';
	}

	if ($n) {
	    unshift @cmd, "echo";
	}

	if ($do_typescript) {
	    if ($^O eq 'freebsd' || $^O eq 'darwin') {
		unshift @cmd, 'script', ($do_filemon ? '-f' : ()), '-a', $typescript_file;
	    } elsif ($^O eq 'linux') {
		my($tmpfh,$tmpfile) = tempfile(UNLINK => 1, SUFFIX => '.typescript.sh') or die $!;
		print $tmpfh "#!/bin/sh\n";
		print $tmpfh join(" ", map { String::ShellQuote::shell_quote($_) } @cmd), "\n";
		close $tmpfh or die $!;
		chmod 0755, $tmpfile or die "Can't chmod $tmpfile: $!";
		@cmd = ('script', '-a', '-c', $tmpfile, $typescript_file);
	    } else {
		die "should not happen";
	    }
	}

	check_disk_free($perl);
	touch_files();

	my $tmp_cmd_file;
	if ($^O eq 'MSWin32') {
	    warn "INFO: hack for MSWin32 to overcome system LIST problems...\n";
	    (my($tmp_fh), $tmp_cmd_file) = tempfile("cpansmokecmd-XXXX", SUFFIX => ".pl", UNLINK => 1);
	    print $tmp_fh "use CPAN;\n";
	    print $tmp_fh $cmd[-1], "\n";
	    close $tmp_fh;
	    @cmd = ($perl, $tmp_cmd_file);
	}

	print STDERR "# PATH=$ENV{PATH}\n";
	print STDERR "# @cmd\n";
	local %ENV = %ENV;
	# See http://schplog.schmorp.de/2015-06-06-stableperl-faq.html
	# XXX decide whether this should stay here or be moved to distroprefs files
	$ENV{PERL_CANARY_STABILITY_NOPROMPT} = 1;
	if ($batch) {
	    #$ENV{PERL_MM_USE_DEFAULT} = 1; --- currently bad idea ... turns CPAN::Reporter questions off
	    $ENV{PERL_EXTUTILS_AUTOINSTALL}=q{--defaultdeps};
	    $ENV{PERL_BATCH} = 'yes'; # private extension, used in 01.DISABLED.yml
	}
	if ($test_unpatched) {
	    $ENV{PERL_TEST_UNPATCHED} = 'yes'; # private extension, used in distroprefs files to skip a fix and force a failure
	}
	if ($for_parallel_smoker) {
	    $ENV{PERL_PARALLEL_SMOKER} = 'yes'; # private extension, used in distroprefs files
	}
	#$ENV{DBIC_NO_WARN_BAD_PERL} = 1; # with the warning messages test output gets so long being unusable
	my $save_perl5opt = $ENV{PERL5OPT};
	if ($module_printused) {
	    $ENV{PERL5OPT} .= " -MModule::PrintUsed";
	}
	if (@hidemod) {
	    $ENV{PERL5OPT} .= " -MDevel::Hide";
	    $ENV{DEVEL_HIDE_VERBOSE} = 0;
	    $ENV{DEVEL_HIDE_PM} = "@hidemod";
	}
	if ($time_fake) {
	    $ENV{PERL5OPT} .= " -MTime::Fake=$time_fake";
	}
	if ($effective_x11_display) {
	    $ENV{DISPLAY} = $effective_x11_display;
	}
	if (defined $perl_hash_seed) {
	    $ENV{PERL_HASH_SEED} = "$perl_hash_seed";
	    if (defined $perl_perturb_keys) {
		$ENV{PERL_PERTURB_KEYS} = $perl_perturb_keys;
	    }
	}
	local $SIG{WINCH} = sub { warn "IGNORE SIGWINCH" };

	local $ENV{PATH} = $ENV{PATH};
	if ($path_with_destroy_perl) {
	    $ENV{PATH} = "$path_with_destroy_perl:$ENV{PATH}"; # it's not MSDOS, so can use ":"
	}
	if ($add_this_perl_path) {
	    my $bin;
	    open my $fh, '-|', $perl, '-MConfig', '-e', 'print $Config{bin}, "\n"'
		or die "Can't run $perl -MConfig ...: $!";
	    chomp($bin = <$fh>);
	    if ($bin) {
		$ENV{PATH} = "$bin:$ENV{PATH}";
		print STDERR "# PATH=$ENV{PATH}\n";
	    } else {
		warn "*** WARNING: cannot find directory for perl binary '$perl'...\n";
	    }
	}

	system @cmd;
	if ($? & 127) {
	    die sprintf("Child died with signal %d, %s coredump\n",
			($? & 127),  ($? & 128) ? 'with' : 'without');
	}
	if (defined $save_perl5opt) {
	    $ENV{PERL5OPT} = $save_perl5opt;
	}
	if ($logfh) {
	    print $logfh "[" . scalar(localtime) . "] $log_preamble DONE\n";
	}

	$action_count += @work_set;

	if ($stop_signal) {
	    warn "Last iteration done, will exit now because of signal...\n";
	    last LOOP_PERLS;
	}

	maybe_pause();
    }
}

END {
    kill_x11_server();

    if ($wait) {
	print STDERR "Smoking finished, enter RETURN to exit: ";
	<STDIN>;
    }

    if (defined $idletermchecker_pid) {
	#kill KILL => $idletermchecker_pid;
	system @idletermchecker_cmd, "-tk", "-s", "-remove", $tty;
    }

    if ($signal_end && time-$start_time>60 && is_in_path("tkmessage") && $^O ne 'darwin') {
	my $msg = "Smoking finished (perls=" . join(", ", @perls) . ", dists=";
	$msg .= @dist_or_mods > 3 ? join(", ", @dist_or_mods[0..2]) . " ..." : join(", ", @dist_or_mods);
	$msg .= ")";
	print STDERR $msg, "\n";
	if (fork == 0) {
	    exec("tkmessage", "-bg", "green", "-fg", "black", $msg);
	}
    }

    xterm_conf(-title => ($last_xterm_title||"") . " FINISHED");

    # Be rather last: maybe the umount command could hang or so, so
    # run the other cleanup stuff earlier.
    if ($need_auto_umount && defined $auto_umount) {
	warn "INFO: Run '$auto_umount'...\n";
	system $auto_umount;
	if ($? != 0) {
	    warn "WARNING: running '$auto_umount' failed.\n";
	}
    }

    # Should be last; may set exit code
    if ($fail_if_nothing_done && !$action_count) {
	$? = 1;
    }
}

sub maybe_pause {
    if (-e $pause_file) {
	xterm_conf('-title', POSIX::strftime('%H:%M', gmtime) . ' Smoker pause');
	my $begin_pause = time;
	do {
	    print STDERR "\rNOTE: 'Pause' file $pause_file detected, delay next iteration (since " . int((time-$begin_pause)/60) . " minute(s))...";
	    sleep 60;
	} while(-e $pause_file);
	print STDERR "\nNOTE: Continuing...\n";
	xterm_conf('-title', 'Smoker continues');
    }
}

sub kill_x11_server {
    if ($use_vncserver && $effective_x11_display) {
	my @cmd = ('vncserver', '-kill', $effective_x11_display);
	system @cmd;
	if ($? != 0) {
	    warn "WARN: killing vnc server with '@cmd' failed: $?";
	}
    }
}

sub find_free_x11_display {
    my %taken_displays;

    # Parse::Netstat has a HUGE prereq chain, so it's optional
    # 0.09 works on FreeBSD and Linux systems
    if (eval { require Parse::Netstat; Parse::Netstat->VERSION(0.11); is_in_path('netstat') && $^O =~ m{^(freebsd|linux|solaris)$} }) {
	my $netstat = Parse::Netstat::parse_netstat(output => scalar `netstat -an`, udp => 0, unix => 0, flavor => $^O);
	for my $active_conn (@{ $netstat->[2]->{active_conns} }) {
	    no warnings 'uninitialized';
	    if (
		($active_conn->{proto} eq 'tcp' || $active_conn->{proto} eq 'tcp4') &&
		$active_conn->{state} eq 'LISTEN' && 
		$active_conn->{local_port} >= 6000 && $active_conn->{local_port} < 6100
	       ) {
		$taken_displays{ $active_conn->{local_port}-6000 } = 1;
	    }
	}
    }
    for my $xlock (glob("/tmp/.X*-lock")) {
	if ($xlock =~ m{\.X(\d+)-lock$}) {
	    $taken_displays{$1} = 1;
	}
    }
    for my $xsock (glob("/tmp/.X11-unix/X*")) {
	if ($xsock =~ m{/X(\d+)$}) {
	    $taken_displays{$1} = 1;
	}
    }
    for my $vncpid (glob("$ENV{HOME}/.vnc/" . hostname . ":*.pid")) {
	if ($vncpid =~ m{:(\d+)\.pid$}) {
	    $taken_displays{$1} = 1;
	}
    }

    for my $display_candidate (
			       reverse(2..9),   # likely to be untaken, or taken by vnc
			       20..99,          # likely to be not taken by ssh x11 forwardings
			       1, 0,            # likely to be taken by real x11 servers
			       reverse(10..19), # likely to be taken by ssh x11 forwardnings
			      ) {
	if (!$taken_displays{$display_candidate}) {
	    return ':' . $display_candidate;
	}
    }

    die "ERROR: Could not find a X11 display candidate. The list of taken displays: " . join(", ", sort { $a <=> $b } keys %taken_displays);
}

# from cpan_allpackages and changed (seek magic)
# may be restricted to only the given perl/arch
sub parse_reports_sent { # takes ~3 seconds
    my(%args) = @_;
    my $onlyperl = delete $args{onlyperl};
    my $onlyarch = delete $args{onlyarch};
    my $skip_tested_fail = delete $args{skiptestedfail};
    my $skip_tested_pass = delete $args{skiptestedpass};
    die "Unhandled arguments: " . join(' ', %args) if %args;

    my $cpan_reporter_dir = $ENV{PERL_CPAN_REPORTER_DIR} || "$ENV{HOME}/.cpanreporter";
    open my $fh, "$cpan_reporter_dir/reports-sent.db"
	or do {
	    warn "*** Can't open $cpan_reporter_dir/reports-sent.db: $!\n";
	    warn "*** Assuming this is the very first run!\n";
	    return;
	};
    if (defined $reports_sent_seek_pos) {
	seek $fh, $reports_sent_seek_pos, 0
	    or die $!;
    }
    while(<$fh>) {
	next if /^#/;
	chomp;
	if (my($action, $dist, $perl, $arch) =
		$_ =~ m{^
			\S+\s+ # phase, ignore
			(\S+)\s+
			(\S+)\s+
			\(([^\)]+)\)\s+
			(.+)
			$}x) {
	    next if (
		     (defined $onlyperl && $perl ne $onlyperl) ||
		     (defined $onlyarch && $arch ne $onlyarch)
		    );
	    next if $skip_tested_fail && $action ne 'FAIL';
	    next if $skip_tested_pass && $action ne 'PASS';
	    my $d = CPAN::DistnameInfo->new($dist.".tar.gz");
	    if (my $old_d = $dists->{$d->dist}->{$perl}->{$arch}) {
		if (safe_version($d->version) <= safe_version($old_d->{dist}->version)) {
		    next;
		}
	    }
	    $dists->{$d->dist}->{$perl}->{$arch} = {dist => $d,
						    action => $action};
	} else {
	    warn "Cannot parse line $_";
	}
    }
    $reports_sent_seek_pos = tell $fh;
}

# from cpan_allpackages
# from cpantestersmatrix:
sub safe_version {
    my $version_string = shift;
    use version;
    no warnings;
    while(length $version_string) {
	local $^W;
	my $version = eval { version->new($version_string) };
	if (!$@) {
	    return $version;
	}
	$version_string = substr($version_string,0,-1);
    }
    "0";
}

sub xterm_conf {
    my(@args) = @_;
    if (!defined $has_xterm_conf) {
	$has_xterm_conf = is_in_path("xterm-conf") ? 1 : 0;
    }
    return if (!$has_xterm_conf);
    my @cmd = ("xterm-conf", "-force", @args);
    system @cmd;
}

sub check_disk_free {
    return if $^O eq 'MSWin32'; # XXX can't check yet
    return if $old_cpan_pm_hack; # don't bother around patching CPAN::HandleConfig calls...

    my($perl) = @_;
    # File::HomeDir is needed because of http://rt.cpan.org/Ticket/Display.html?id=34066
    my @cmd = ($perl);
    if ($perl =~ /5\.6\.2/ || $perl =~ /5\.005/) {
	# Preload to avoid segfaults
	push @cmd, '-MFile::HomeDir';
    }
    push @cmd, '-MCPAN', '-e', '$CPAN::Be_Silent=1;CPAN::HandleConfig->load; print $CPAN::Config->{build_dir}';
    open my $fh, "-|", @cmd
	or die $!;
    my $build_dir;
    while(<$fh>) { # Why is this complicated constructed needed to get the build_dir out of the output?
 	chomp;
	$build_dir = $_;
	last if $build_dir;
    }
    close $fh;
    if (!$build_dir) {
	die "Should not happen: cannot parse build directory using <@cmd>";
    }
    if (!-d $build_dir) {
	die <<EOF;
Build directory <$build_dir> for perl <$perl> does not exist.
Usually this can be fixed by running a dummy build once, e.g.

    $perl -MCPAN -eshell
    test Kwalify
    quit

EOF
    }

    for my $def (
		 [\$min_build_dir_avail,   '-minbuilddiravail'],
		 [\$min_build_dir_cleanup, '-minbuilddircleanup'],
		) {
	my($varref, $name) = @$def;
	if ($$varref) {
	    $$varref =~ s{([\d\.]+)([kMG])}{int($1*($2 eq "k" ? 1024 : $2 eq "M" ? 1024**2 : $2 eq "G" ? 1024**3 : die))}e;
	    if ($$varref !~ m{^\d+$}) {
		die "(expanded) $name value '$$varref' does not look like an integer number";
	    }
	}
    }
    if (_can_df()) {
	# Note: addperday=>1 is necessary only for the build_dir,
	# because the per-day directory might not exist yet, so we
	# have to operate on the parent. In the tmpdir case the
	# per-day directory is already created.
	check_disk_free_directory($build_dir, $min_build_dir_avail, $min_dir_inodes_percent, autoclean => 1, addperday => 1, minbuilddircleanup => $min_build_dir_cleanup);
	require File::Spec;
	check_disk_free_directory(File::Spec->tmpdir, $min_tmp_dir_avail, $min_dir_inodes_percent, autoclean => 1);
    } else {
	warn <<EOF;
***************************************************************************
* WARNING:
*
*   Filesys::DfPortable and Filesys::Df are not available,
*   so no disk free check can be done
*
***************************************************************************
EOF
    }
}

sub _can_df {
    eval { require Filesys::DfPortable; 1 } || eval { require Filesys::Df; 1 } || _has_modern_gnu_df();
}

sub _has_modern_gnu_df {
    return 0 if $^O ne 'linux';
    my $version_output = qx(df --version);
    return 0 if !length $version_output;
    my($version) = $version_output =~ m{df \(GNU coreutils\) (\d+\.\d+)};
    return 0 if !$version;
    return $version >= 8.21; # support for --output, see http://savannah.gnu.org/forum/forum.php?forum_id=7505
}

sub _df {
    my $dir = shift;
    if (defined &Filesys::DfPortable::dfportable) {
	Filesys::DfPortable::dfportable($dir);
    } elsif (defined &Filesys::Df::df) {
	my $dfres = Filesys::Df::df($dir);
	if ($dfres) {
	    $dfres->{bavail} *= 1024;
	}
	$dfres;
    } elsif ($^O eq 'linux') {
	my @cmd = ('df', '--output=avail,iavail,itotal', '--block-size=k', $dir);
	open my $fh, '-|', @cmd
	    or die "Error while running '@cmd': $!";
	<$fh>; # header
	chomp;
	my($bavail, $iavail, $itotal) = split /\s+/, scalar <$fh>;
	$bavail =~ s{K$}{};
	$bavail *= 1024;
	my $dfres = {
		     bavail => $bavail,
		     favail => $iavail,
		     files  => $itotal,
		    };
	$dfres;
    } else {
	die "FATAL: should never happen: cannot do df";
    }
}

sub check_disk_free_directory {
    my($dir, $min_space_free_bytes, $min_inode_free_percent, %opts) = @_;
    my $autoclean = delete $opts{autoclean};
    my $addperday = delete $opts{addperday};
    my $min_build_dir_cleanup_bytes = delete $opts{minbuilddircleanup};
    die 'Unhandled options: ' . join(' ', %opts) if %opts;

    # In the first pass check for -minbuilddircleanup value
    # If cleaning up to this value fails, then lower the limit
    # for $min_space_free_bytes
    my $check_free_bytes = $autoclean && $min_build_dir_cleanup_bytes ? $min_build_dir_cleanup_bytes : $min_space_free_bytes;

    my $need_to_restore_xterm_title;
    my $last_remove_candidate;
    my %warned;
    while () {
	my $dfres = _df($dir);
	if (!$dfres) {
	    die "Cannot get filesys information for $dir";
	}

	my $space_ok = 1;
	my $inode_ok = 1;

	my $inode_avail_percent;
	{
	    if ($dfres->{files}) {
		$inode_avail_percent = $dfres->{favail} / $dfres->{files} * 100;
		if ($inode_avail_percent < $min_inode_free_percent) {
		    $inode_ok = 0;
		}
	    }
	}

	if ($dfres->{bavail} < $check_free_bytes) {
	    $space_ok = 0;
	}

	last if $space_ok && $inode_ok;

	if (!$space_ok) {
	    print STDERR qq{Less than $check_free_bytes bytes on $dir available: $dfres->{bavail}.\n};
	}
	if (!$inode_ok) {
	    print STDERR qq{Less than $min_inode_free_percent% inodes available on $dir: $inode_avail_percent%.\n};
	}

	if ($autoclean && $per_day_build_dir) {
	    require Time::Local;
	    my $oldest_directory;
	    my $parent_dir = $dir;
	    my $date_rx = qr{^(20\d{2})([012]\d)([0123]\d)([012]\d)?$};
	    my @clean_candidates;
	    opendir my $dirfh, $parent_dir
		or die "UNEXPECTED ERROR: can't open $parent_dir: $!";
	    while(defined(my $entry = readdir($dirfh))) {
		if ($entry =~ $date_rx) {
		    push @clean_candidates, $entry;
		}
	    }

	    if (@clean_candidates) {
		# pick oldest one
		my($entry) = sort @clean_candidates;
		$entry =~ $date_rx;
		my $hour = $4 || 0;
		my $epoch = Time::Local::timelocal(0,0,$hour,$3,$2-1,$1);
		if (time - $epoch >= (3+3)*3600) { # older than 3 plus 3 hours
		    $oldest_directory = "$parent_dir/$entry";
		}
	    }
	    if (!$oldest_directory) {
		if ($min_space_free_bytes < $check_free_bytes) {
		    warn "INFO: cannot cleanup under -minbuilddircleanup limit, switch to -minbuilddiravail now...\n";
		    $check_free_bytes = $min_space_free_bytes;
		    next;
		} else {
		    warn "NOTE: No candidate for cleanup of old build directories found.\n";
		}
	    } else {
		if (defined $last_remove_candidate && $last_remove_candidate eq $oldest_directory) {
		    if (!$warned{$last_remove_candidate}) {
			warn "*** WARNING: The last removal attempt for '$last_remove_candidate' was not successful, please remove manually!\n";
			$warned{$last_remove_candidate} = 1;
		    }
		} else {
		    warn "INFO: Remove now oldest build directory: $oldest_directory\n";
		    rmtree($oldest_directory, 0, 0);
		    $last_remove_candidate = $oldest_directory;
		    next; # retry
		}
	    }
	}

	xterm_conf('-title', 'Please cleanup disk for cpan_smoke_modules...');
	$need_to_restore_xterm_title = 1;
	print STDERR qq{Please cleanup the directory and go on with <RETURN>: };
	if (is_interactive()) {
	    local $SIG{ALRM} = sub { die "Timeout" };
	    alarm(60*10);
	    eval {
		<STDIN>;
	    };
	    alarm(0);
	    if ($@ && $@ =~ /Timeout/) {
		warn "Timeout (at " . POSIX::strftime("%H:%M:%S", localtime) . "), check again if disk space is available...\n";
	    }
	    sleep 1; # help against overruns
	} else {
	    print STDERR qq{(sleeping for 60 seconds...)\n};
	    sleep 60;
	}
    }

    if ($need_to_restore_xterm_title) {
	xterm_conf('-title', 'Continuing cpan_smoke_modules...');
    }
    return 1;
}

# A list of files, probably in temporary directory, which need regular touch
# --- otherwise other cleanup jobs could remove them.
sub touch_files {
    for my $file (@touch_files) {
	if (-e $file) {
	    my $now = time;
	    utime $now, $now, $file
		or warn "Can't touch $file: $!";
	}
    }
}

sub _is_install_like_action {
    $do_action eq 'install' || grep { $_ eq 'install_tested' } @post_actions;
}

sub predictable_tempfile {
    $has_private_tmpdir or return;
    eval { require Fcntl; 1 } or return;
    defined &File::Temp::_deferred_unlink or return;
    if (defined &Fcntl::O_EXCL) {
	for my $counter (0..99) {
	    my $filename = sprintf "$ENV{TMPDIR}/cpanreporter_%03d_config.ini", $counter;
	    if (sysopen my $fh, $filename, &Fcntl::O_RDWR|&Fcntl::O_CREAT|&Fcntl::O_EXCL) {
		File::Temp::_deferred_unlink($fh, $filename, 0); # XXX shouldn't use private function
		return ($fh, $filename);
	    }
	}
	warn <<EOF;
WARN: Cannot create a predictable tempfile for cpanreporter_config.ini.
      Please cleanup files in $ENV{TMPDIR} manually.
EOF
    }
    return;
}

sub per_day_directory_name {
    my $time = time;
    my $today = POSIX::strftime('%Y%m%d', localtime $time);
    my $hour = POSIX::strftime('%H', localtime $time);
    $hour = sprintf '%02d', int($hour / 3) * 3;
    $today . $hour;
}

# Rather slow, has to load CPAN.pm to get version.
sub is_CPAN_pm_broken {
    my $perl = shift;

    my $cpan_ver = do {
	my @cmd = ($perl, "-we", q{use CPAN; print CPAN->VERSION(0)});
	@cmd = "@cmd" if $^O eq 'MSWin32'; # list form of pipe not implemented
	open my $fh, "-|", @cmd
	    or die "Command @cmd failed: $!";
	local $/;
	<$fh>;
    };
    return ($cpan_ver == 1.9258);
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/work/srezic-repository 
# REPO MD5 81c0124cc2f424c6acc9713c27b9a484

sub is_in_path {
    my($prog) = @_;
    return $prog if (file_name_is_absolute($prog) and -f $prog and -x $prog);
    require Config;
    %Config::Config = %Config::Config if 0; # cease -w
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"
		if (-x "$_\\$prog.bat" ||
		    -x "$_\\$prog.com" ||
		    -x "$_\\$prog.exe" ||
		    -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/work/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8

BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

# REPO BEGIN
# REPO NAME save_pwd /home/e/eserte/work/srezic-repository 
# REPO MD5 0f7791cf8e3b62744d7d5cfbd9ddcb07

sub save_pwd (&) {
    my $code = shift;
    require Cwd;
    my $pwd = Cwd::getcwd();
    if (!defined $pwd) {
        warn "No known current working directory";
    }
    eval {
	$code->();
    };
    my $err = $@;
    if (defined $pwd) {
        chdir $pwd or die "Can't chdir back to $pwd: $!";
    }
    die $err if $err;
}
# REPO END

# REPO BEGIN
# REPO NAME is_interactive /home/e/eserte/work/srezic-repository 
# REPO MD5 3c8170d60ac3c3648e9b93a995ec6615

sub is_interactive {
    if ($^O eq 'MSWin32' || !eval { require POSIX; 1 }) {
	# fallback
	return -t STDIN && -t STDOUT;
    }

    # from perlfaq8
    open(TTY, "/dev/tty") or return 0;
    my $tpgrp = POSIX::tcgetpgrp(fileno(*TTY));
    my $pgrp = getpgrp();
    if ($tpgrp == $pgrp) {
	1;
    } else {
	0;
    }
}
# REPO END

__END__

=head1 NAME

cpan_smoke_modules - test and report CPAN modules with more perls

=head1 SYNOPSIS

    cpan_smoke_modules module1 author/distribution.tar.gz ...

=head1 DESCRIPTION

Smoke test the given modules with all or some available perls.

You can supply module names (e.g. C<DBD::mysql>) or full distribution
names (e.g. C<SREZIC/Tk-804.028.tar.gz>, with or without the
additional directory prefix C<S/SR>) or partial distibution names
(e.g. C<Tk-804.028>). Partial distribution names are currently (August
2009) nearly unique enough (there's only one exception). Note that
additional grepping is used for partial distribution names, so avoid
it if possible.

Some options like C<-skiptested> can only operate if a distribution
name (full or partial) was given, but not for module names.

=head2 OPTIONS

=over

=item -n

Dry run.

=item -perl I<executable> [-perl ...]

Specify which perl to use. Can be specified multiple times.

=item -pv I<version>,I<version>,...

This is the short version of the B<-perl> option. Use the perl
versions, separated by commas. This assumes that the perl executables
are installed or symlinked as F</usr/local/bin/perlX.Y.Z>.

=item -pv I<cond>I<version>

Use all available perl versions, restricted by the given condition.
I<cond> may be C<< < >>, C<< <= >>, C<< => >>, or C<< > >>. I<version>
is a two-dot version (e.g. C<5.8.9>). Example: C<< -pv >=5.10.0 >>.
Don't forget that C<< > >> and C<< < >> have to be escaped in most
shells.

=item -allperls

Use all installed perls. This is the default unless a specific perl
version via the C<-perl> or C<-pv> option is requested.

=item -skipsystemperl

Skip a perl in F</usr/local/bin> which is symlinked to the system perl
(F</usr/bin/perl>).

=item -skipperl /path/to/perl

Skip this perl if running in C<-allperls> mode. This option may be
given multiple times.

=item -install

Do not only test, but also install.

=item -reinstall

Test and reinstall, if test was successful. Note that reinstall really
means _re_install --- the module won't be reinstalled if it isn't
already installed.

=item -reverse

Reverse the list of modules/distributions to test.

=item -[no]sqlite

Use/do not use L<C<CPAN::SQLite>>. On by default. If C<CPAN::SQLite> is
not available, then the normal non-sqlite internal storage will be
used.

=item -fl I<file>

Specify a file with the listed distributions/modules.

=item -builddirreuse

set the build_dir_reuse flag of CPAN.pm. Not well tested.

=item -warntimeout I<seconds>

Seconds to wait before showing the warn dialog. Default is 60 seconds.

=item -as-root

Run build and test as root, using L<sudo(1)>.

Note that this does not work if the reports directory is specially
mounted (e.g. via sshfs or nfs) and root does not have permissions to
write to this directory.

Note also that files and directories created while running
C<cpan_smoke_modules> as root will belong to root, and might need to
be handled specially afterwards. Most notably this is the build
directory and the downloaded tarball, including all possbily missing
parent directories.

=item -vnc

Make a VNC server during the smoke run. It is killed after first run.
Note that some (all?) VNC implementations ask for a password when
called first time.

=item -[no]limits

Run the smoker with resource limits. Limits are currently set to 1GB
data size, 1h CPU runtime, and 2048 open file descriptors.

Requires that either L<limits(1)> (BSD systems) or L<BSD::Resource> is
installed. This option is on by default.

=item -[no]typescript

Create a typescript of the smoke run. The output is written to
F<~/.cpan_smoke_modules_typescripts> in date-specific subdirectories.

Requires L<script(1)> to be available, and works only for FreeBSD, Mac
OS X and Linux. This option is on by default.

L<script(1)> is usually implemented by creating a pseudo-terminal, so
a password in a L<sudo> session is not shared across multiple smoker
runs. If this is annoying (i.e. when using the C<-install> or
C<-as-root> option), then set C<-notypescript>.

=item -skiptested

Skip all given distribution names (not module names!) if they were
already tested for this perl. Tested distributions are determined by
reading F<~/.cpanreporter/reports-sent.db>.

Distribution names should be given including author, version and
suffix, e.g. C<SREZIC/Kwalify-1.22.tar.gz>. Some heuristics are used
if either author, version or suffix are missing to resolve to the full
name, but this may fail.

=item -skiptestedpass

Skip all given distribution names if they were already tested with a
PASS for this perl.

=item -skiptestedfail

Skip all given distribution names if they were already tested with a
FAIL for this perl.

=item -randomhashes

Don't set any environment variables affecting hash randomization (only
for perls >= 5.17.6), in other words, hashes have random order.

=item -deterministichashes

Use deterministic hashes by setting C<PERL_HASH_SEED> to 0 and
C<PERL_PERTURB_KEYS> to C<NO>.

=item -hashseed I<seed>

=item -hashseed I<seed>:yes

Set a specific seed value for C<PERL_HASH_SEED> and optionally a value
for C<PERL_PERTURB_KEYS> (defaults to C<NO> if this option is used).
Note that technically there's no C<PERL_PERTURB_KEYS=YES> in perl;
it's just the absence of this environment variable.

=item -[no]failifnothingdone

Exit with a false value (1) if no distribution is tested. This usually
may happen in conjunction with a C<-skiptested*> option. Use case:
test a randomly failing distribution until it really fails:

    while cpan_smoke_modules -pv 5.22.1 -skiptestedfail Foo-Bar-1.23 -failifnothingdone; do sleep 1; done

=item -automount 'cmd ...'

=item -autoumount 'cmd ...'

Specify commands for automatically mounting and unmounting of the
F<~/var/cpansmoker/new> directory (or whatever directory was specified
with C<-reportsworkflowdir>).

The automount command is executed before the smoking starts, and only
if the F<.../new> directory does not exist. The program exits if the
automount command was not successful.

The autoumount command is executed after finishing all smoking, and
only if the automount command was executed in this session. This means
an already mounted directory stays mounted.

=item -addthisperlpath

Make sure that the path containing the currently used perl is first in
the active C<PATH>. This may workaround errors when tests are not
using C<$^X>, but the first perl in C<PATH> which may be the system
perl.

=item -sysdeps

=item -sysdeps-batch

=item -no-sysdeps

Use the module L<CPAN::Plugin::Sysdeps> to install system packages if
required for the currently tested CPAN modules. Using C<-sysdeps> the
installation is interactive: the user is always asked before
installing system packages. With C<-sysdeps-batch> the installation is
automatic as much as possible, but read L<CPAN::Plugin::Sysdeps/* Batch
mode>.

=back

=head1 DEFAULT CONFIGURATION

All command line options may be specified as defaults in
F<~/.cpansmokemodulesrc>. Parsing of the file is done with
L<Text::ParseWords/shellwords>. Multiple lines are possible. Lines
starting with a C<#> are treated as comments and are ignored.

Parsing of this file is skipped if the option C<-skiprcfile> is given.

=head1 NOTES

Assumption is that distributions are sorted in reverse order, that is
newest first. Any later distribution version on the command line will
be removed from the list.

L<cpan_smoke_modules> creates a private temporary directory
F<cpansmoker-$USERID>. This directory is created either in the
user-specific runtime directory (as specified by the
C<XDG_RUNTIME_DIR> environment variable, usually something like
F</run/user/$USERID>), or F</var/tmp>, or F</tmp>.

A running C<cpan_smoke_modules> process may be cleanly terminated with
a C<HUP> signal. The execution of the script is paused if a file
F<~/.cpansmokemodulespause> exists. In both cases, termination and
pause will not happen immediately, only after a set of modules is
tested.

=head1 AUTHOR

Slaven ReziE<0x0107>

=cut
