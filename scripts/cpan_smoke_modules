#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: cpan_smoke_modules,v 1.7 2007/10/06 21:47:38 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2007 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use Getopt::Long;
my @perls = qw(perl5.10.0 perl5.8.8 perl5.6.2 perl5.00505);
my $do_action = "report";
my $warntimeout = 60;
my $n;
GetOptions("n" => \$n,
	   "install" => sub { $do_action = "install" },
	   "warntimeout=i" => \$warntimeout,
	  )
    or die "usage!";
my @dist_or_mods = @ARGV;
if (!@dist_or_mods) {
    die "dist or mod?";
}

# no idletermchecker in no exec mode:
if ($n && $warntimeout) {
    $warntimeout = undef;
}

my $idletermchecker_pid;
if ($warntimeout) {
    if (is_in_path("idletermchecker")) {
	chomp(my $tty = `tty`);
	if ($tty) {
	    $idletermchecker_pid = fork;
	    if ($idletermchecker_pid == 0) {
		exec "idletermchecker", "-timeout", $warntimeout, "-q", $tty;
		die $!;
	    }
	} else {
	    print STDERR "NOTE: cannot get tty, idletermchecker will not run.\n";
	}
    } else {
	print STDERR "NOTE: idletermchecker is not available.\n";
    }
}

for my $perl (@perls) {
    next if !is_in_path($perl);
    print STDERR "#"x70,"\n";
    print STDERR "# $perl\n";
    my $dist_or_mods_line = join(", ", map { qq{"$_"} } @dist_or_mods);
    my @cmd = ($perl, "-MCPAN", "-e", $do_action.qq{($dist_or_mods_line)});
    if ($n) {
	unshift @cmd, "echo";
    }
    print STDERR "# # @cmd\n";
    system @cmd;
    if ($? & 127) {
	die sprintf("Child died with signal %d, %s coredump\n",
		    ($? & 127),  ($? & 128) ? 'with' : 'without');
    }
}

END {
    #kill KILL => $idletermchecker_pid if defined $idletermchecker_pid;
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/work/srezic-repository 
# REPO MD5 81c0124cc2f424c6acc9713c27b9a484

=head2 is_in_path($prog)

=for category File

Return the pathname of $prog, if the program is in the PATH, or undef
otherwise.

DEPENDENCY: file_name_is_absolute

=cut

sub is_in_path {
    my($prog) = @_;
    return $prog if (file_name_is_absolute($prog) and -f $prog and -x $prog);
    require Config;
    %Config::Config = %Config::Config if 0; # cease -w
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"
		if (-x "$_\\$prog.bat" ||
		    -x "$_\\$prog.com" ||
		    -x "$_\\$prog.exe" ||
		    -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/work/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8

=head2 file_name_is_absolute($file)

=for category File

Return true, if supplied file name is absolute. This is only necessary
for older perls where File::Spec is not part of the system.

=cut

BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

__END__
