#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: cpan_smoke_modules,v 1.22 2007/11/06 18:09:46 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2007 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use Config qw(%Config);
use Getopt::Long;
use CPAN;
use CPAN::DistnameInfo;
use IO::Handle;

sub save_pwd (&);

$ENV{PATH} = $ENV{PATH} . $Config{path_sep} . $FindBin::RealBin;

my $start_time = time;

my @perls;
my $pv;
my $do_action = "report";
my $warntimeout = 60;
my $n;
my $use_sqlite = 1;
my $fl;
GetOptions("n" => \$n,
	   "install" => sub { $do_action = "install" },
	   "warntimeout=i" => \$warntimeout,
	   'perl=s@' => \@perls,
	   'pv=s' => \$pv,
	   'sqlite!' => \$use_sqlite,
	   'fl=s' => \$fl,
	  )
    or die "usage!";
my @dist_or_mods = @ARGV;
if ($fl) {
    open my $fh, $fl
	or die "Cannot open filelist $fl: $!";
    while(<$fh>) {
	chomp;
	push @dist_or_mods, split / /;
    }
}
if (!@dist_or_mods) {
    die "dist or mod?";
}

if ($pv) {
    push @perls, map { "perl$_" } split /,/, $pv;
}

if (!@perls) {
    @perls = qw(perl5.10.0 perl5.8.8 perl5.6.2 perl5.00505);
}

# no idletermchecker in no exec mode:
if ($n && $warntimeout) {
    $warntimeout = undef;
}

chomp(my $tty = `tty`);

my $idletermchecker_pid;
if ($warntimeout) {
    if (is_in_path("idletermchecker")) {
	if ($tty) {
	    $idletermchecker_pid = fork;
	    if ($idletermchecker_pid == 0) {
		exec "idletermchecker", "-timeout", $warntimeout, "-q", $tty;
		die $!;
	    }
	} else {
	    print STDERR "NOTE: cannot get tty, idletermchecker will not run.\n";
	}
    } else {
	print STDERR "NOTE: idletermchecker is not available.\n";
    }
}

{
    my @new_dist_or_mods;
    my %seen_dist;
    for my $dist_or_mod (@dist_or_mods) {
	my $d_info = CPAN::DistnameInfo->new($dist_or_mod);
	if (!$d_info->dist) { # it's probably a mod name
	    push @new_dist_or_mods, $dist_or_mod;
	} elsif ($seen_dist{$d_info->dist}) {
	    warn "Remove " . $d_info->distvname . " from list...\n";
	} else {
	    push @new_dist_or_mods, $dist_or_mod;
	    $seen_dist{$d_info->dist}++;
	}
    }
    @dist_or_mods = @new_dist_or_mods;
}

open my $logfh, ">>", "$ENV{HOME}/.cpan_smoke_modules.log"
    or warn "WARNING: Cannot write to logfile: $!";
$logfh->autoflush(1);

CPAN::HandleConfig->load;
my $prefs_dir = $CPAN::Config->{prefs_dir};

for my $perl (@perls) {
    if (!is_in_path($perl)) {
	warn "*** WARNING: $perl is not available, skipping...\n";
	next;
    }
    print STDERR "#"x70,"\n";
    print STDERR "# $perl\n";
    my $log_preamble = "$perl: $dist_or_mods[0] .. $dist_or_mods[-1]";
    if ($logfh) {
	print $logfh "[" . scalar(localtime) . "] $log_preamble BEGIN\n";
    }
    if (is_in_path("xterm-config")) {
	system(qq{xterm-config -title "smoke($tty): $perl"});
    }

    if ($prefs_dir && -d $prefs_dir && -r "$prefs_dir/SlayMakefile") {
	save_pwd {
	    if (chdir $prefs_dir) {
		my @cmd = qw(slaymake);
		system(@cmd);
		if ($? != 0) {
		    die "Error while executing <@cmd>";
		}
	    }
	};
    }

    my $dist_or_mods_line = join(", ", map { qq{qq{$_}} } @dist_or_mods);
    my $cpan_shell_init = "";
    if ($do_action eq 'report') {
	$cpan_shell_init .= q{CPAN::HandleConfig->load; $CPAN::Config->{urllist} =[qw(ftp://ftp.funet.fi/pub/CPAN/)]; };
    } else {
	$cpan_shell_init .= "";
    }
    if ($use_sqlite) {
	$cpan_shell_init .= q#if (eval { require CPAN::SQLite; 1; }) { $CPAN::Config->{use_sqlite}=1; } #;
    }
    my @cmd = ($perl, "-MCPAN", "-e",
	       $cpan_shell_init . $do_action.qq{($dist_or_mods_line)},
	      );
    if (is_in_path("limits")) {
	unshift @cmd, "limits", "-d", 500*1024*1024;
    }
    if ($n) {
	unshift @cmd, "echo";
    }
    print STDERR "# @cmd\n";
    system @cmd;
    if ($? & 127) {
	die sprintf("Child died with signal %d, %s coredump\n",
		    ($? & 127),  ($? & 128) ? 'with' : 'without');
    }
    if ($logfh) {
	print $logfh "[" . scalar(localtime) . "] $log_preamble DONE\n";
    }
}

END {
    if (defined $idletermchecker_pid) {
	kill KILL => $idletermchecker_pid;
	if (time-$start_time>60 && is_in_path("tkmessage")) {
	    system("tkmessage", "-bg", "green", "-fg", "black", "Smoking finished");
	}
    }
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/work/srezic-repository 
# REPO MD5 81c0124cc2f424c6acc9713c27b9a484

sub is_in_path {
    my($prog) = @_;
    return $prog if (file_name_is_absolute($prog) and -f $prog and -x $prog);
    require Config;
    %Config::Config = %Config::Config if 0; # cease -w
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"
		if (-x "$_\\$prog.bat" ||
		    -x "$_\\$prog.com" ||
		    -x "$_\\$prog.exe" ||
		    -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/work/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8

BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

# REPO BEGIN
# REPO NAME save_pwd /home/e/eserte/work/srezic-repository 
# REPO MD5 0f7791cf8e3b62744d7d5cfbd9ddcb07

=head2 save_pwd(sub { ... })

=for category File

Save the current directory and assure that outside the block the old
directory will still be valid.

=cut

sub save_pwd (&) {
    my $code = shift;
    require Cwd;
    my $pwd = Cwd::cwd();
    eval {
	$code->();
    };
    my $err = $@;
    chdir $pwd or die "Can't chdir back to $pwd: $!";
    die $err if $err;
}
# REPO END

__END__

=head1 NAME

cpan_smoke_modules - test and report CPAN modules with more perls

=head1 SYNOPSIS

    cpan_smoke_modules module1 author/distribution.tar.gz ...

=head1 NOTES

Assumption is that distributions are sorted in reverse order, that is
newest first. Any later distribution version on the command line will
be removed from the list.

    
=head1 TODO

    * evtl. die recent-Liste http://search.cpan.org/recent automatisch
      holen und abarbeiten, dabei aber Duplikate (ältere Versionen)
      ignorieren (-> CPAN::DistInfo?)

    * evtl. auch das zuletzt getestete Modul merken und/oder
      ~/.cpanreporter/reports-sent.db verwenden, um zu sehen, welche
      Dists getestet werden müssen (leider sind dort die disabled=1
      markierten Dists nicht enthalten)

=head1 AUTHOR

Slaven ReziE<0x0107>

=cut
