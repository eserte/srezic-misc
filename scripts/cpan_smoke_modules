#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: cpan_smoke_modules,v 1.49 2008/03/13 20:22:23 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2007, 2008 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use FindBin;
use Config qw(%Config);
use Getopt::Long;
use CPAN;
use CPAN::DistnameInfo;
use IO::Handle;

sub save_pwd (&);

$ENV{PATH} = $ENV{PATH} . $Config{path_sep} . $FindBin::RealBin;

my $start_time = time;

my $addarch = $Config{myarchname} ? "_$Config{myarchname}" : "";
my $cpan_smoke_last = "$ENV{HOME}/.cpan_smoke_modules$addarch.last";
my $cpan_smoke_log  = "$ENV{HOME}/.cpan_smoke_modules$addarch.log";

my @blacklist_author = qw(MLEHMANN);
my @perls;
my $pv;
my $do_action = "test"; # and report
my $warntimeout = 60;
my $n;
my $r;
my $rr; # reverse a working set (-splitdists) only
my $use_sqlite = 1;
my $fl;
my $do_continue;
my $do_recent;
my $recent_url = 'ftp://ftp.funet.fi/pub/CPAN/authors/id/RECENT-2d.yaml';
my $interactive;
my $wait;
my $batch;
my $all_perls;
my $build_dir_reuse = 0; # not default - startup is tooo slow
my $split_dists = $^O eq 'MSWin32' ? 5 : 50;
my $has_xterm_config;
Getopt::Long::Configure('noauto_abbrev');
GetOptions("n" => \$n,
	   "r|reverse" => \$r,
	   "rr" => \$rr,
	   "a|allperls!" => \$all_perls,
	   "i|install" => sub { $do_action = "install" },
	   "warntimeout=i" => \$warntimeout,
	   'perl=s@' => \@perls,
	   'pv=s' => \$pv,
	   'sqlite!' => \$use_sqlite,
	   'fl=s' => \$fl,
	   'c|cont|continue' => \$do_continue,
	   'recent' => \$do_recent,
	   'recenturl=s' => \$recent_url,
	   'interactive!' => \$interactive,
	   'wait!' => \$wait,
	   'batch!' => \$batch,
	   'builddirreuse!' => \$build_dir_reuse,
	   'splitdists=i' => \$split_dists,
	  )
    or die "usage!";
my @dist_or_mods = @ARGV;
if ($fl) {
    open my $fh, $fl
	or die "Cannot open filelist $fl: $!";
    while(<$fh>) {
	chomp;
	push @dist_or_mods, split / /;
    }
}
if ($do_continue || $do_recent) {
    require LWP::UserAgent;
    require YAML;

    my $last_run_path;

    if ($do_continue) {
	require File::ReadBackwards;
	if (my $lastfh = File::ReadBackwards->new($cpan_smoke_last)) {
	    while (!$lastfh->eof) {
		my $line = $lastfh->readline;
		next if $line =~ m{^\s*(#|$)};
		chomp($last_run_path = $line);
		last;
	    }
	    $lastfh->close;
	}
    }
	
    local $ENV{FTP_PASSIVE} = 1;
    my $ua = LWP::UserAgent->new;
    my $resp = $ua->get($recent_url);
    if (!$resp->is_success) {
	die "Cannot get successful request from $recent_url: " . $resp->status_line;
    }
    my $recent = YAML::Load($resp->decoded_content);
    if (!$recent) {
	die "Cannot get YAML content";
    }
    for my $item (@$recent) {
	next if $item->{path} =~ m{(\.patch\.gz|CHECKSUMS|\.readme|\.meta)$};
	last if $last_run_path && $item->{path} eq $last_run_path;
	push @dist_or_mods, $item->{path};
    }
    if (!@dist_or_mods) {
	warn "No new distributions to test.\n";
	exit 0;
    }
}
if (!@dist_or_mods) {
    die "dist or mod?";
}

if ($pv) {
    push @perls, map { "perl$_" } split /,/, $pv;
}

if (!@perls) {
    @perls = qw(perl5.10.0 perl5.8.8 perl5.6.2 perl5.00505);
    if ($all_perls) {
	push @perls, qw(perl5.10.0t perl5.8.8t);
    }
}

{
    my @new_perls;
    for my $perl (@perls) {
	if (!is_in_path($perl)) {
	    warn "*** WARNING: $perl is not available, removing from list...\n";
	} else {
	    push @new_perls, $perl;
	}
    }
    @perls = @new_perls;
    if (!@perls) {
	die "*** ERROR: Could not find any requested perl.\n";
    }
}

{
    my @new_dist_or_mods;
    my %seen_dist;
    my %seen_mod;
    my %blacklist_author = map{($_,1)} @blacklist_author;
    for my $dist_or_mod (@dist_or_mods) {
	my $d_info = CPAN::DistnameInfo->new($dist_or_mod);
	if (!$d_info || !$d_info->dist) {
	    # It's a module
	    if ($seen_mod{$dist_or_mod}) {
		warn "Remove " . $dist_or_mod . " from list...\n";
	    } else {
		push @new_dist_or_mods, $dist_or_mod;
		$seen_mod{$dist_or_mod}++;
	    }
	} else {
	    my $cpanid = $d_info->cpanid;
	    if (!$cpanid) {
		# assume "short" distname
		($cpanid) = $dist_or_mod =~ m{([^/]+)};
	    }
	    if ($cpanid && $blacklist_author{$cpanid}) {
		warn "Remove blacklisted distribution " . $d_info->distvname . " from list...\n";
		next;
	    }
	    my $dist_key = $d_info->dist."/".$d_info->maturity;
	    if (!$d_info->dist) { # it's probably a mod name
		push @new_dist_or_mods, $dist_or_mod;
	    } elsif ($seen_dist{$dist_key}) {
		warn "Remove " . $d_info->distvname . " (maturity=" . $d_info->maturity . ") from list...\n";
	    } else {
		push @new_dist_or_mods, $dist_or_mod;
		$seen_dist{$dist_key}++;
	    }
	}
    }
    @dist_or_mods = @new_dist_or_mods;
}

if (!@dist_or_mods) {
    warn "No distributions to test.\n";
    exit 0;
}

if ($r) {
    @dist_or_mods = reverse @dist_or_mods;
}

if ($interactive) {
    print STDERR "Continue tests with the following perl versions
    @perls
and CPAN distributions or modules
    @dist_or_mods
 (Y/n) ";
    my $yn = <STDIN>;
    exit 0 if $yn =~ m{^n}i;
}

# no idletermchecker in no exec mode:
if ($n && $warntimeout) {
    $warntimeout = undef;
}
# no idletermchecker if there's no DISPLAY
if (!$ENV{DISPLAY}) {
    $warntimeout = undef;
}

chomp(my $tty = `tty`);

my $idletermchecker_pid;
if ($warntimeout) {
    if (is_in_path("idletermchecker")) {
	if ($tty) {
	    $idletermchecker_pid = fork;
	    if ($idletermchecker_pid == 0) {
		exec "idletermchecker", "-timeout", $warntimeout, "-q", $tty;
		die $!;
	    }
	} else {
	    print STDERR "NOTE: cannot get tty, idletermchecker will not run.\n";
	}
    } else {
	print STDERR "NOTE: idletermchecker is not available.\n";
    }
}

# neither "nice" on Windows, nor setpriority or so:
if ($^O eq 'MSWin32') {
    eval {
	require Win32::Process;
	Win32::Process::Open(my $proc, $$, 0)
		or die($^E);
	$proc->SetPriorityClass(Win32::Process::IDLE_PRIORITY_CLASS())
	    or die($^E);
    };
    warn $@ if $@;
}

open my $logfh, ">>", $cpan_smoke_log
    or warn "WARNING: Cannot write to logfile $cpan_smoke_log: $!";
$logfh->autoflush(1);

CPAN::HandleConfig->load;
my $prefs_dir = $CPAN::Config->{prefs_dir};

for my $perl (@perls) {
    print STDERR "#"x70,"\n";
    print STDERR "# $perl\n";
    my @dist_or_mods = @dist_or_mods;
    while (@dist_or_mods) {
	my @work_set;
	if (!$split_dists) {
	    @work_set = @dist_or_mods;
	    @dist_or_mods = ();
	} else {
	    my $i = $split_dists;
	    while(@dist_or_mods && $i > 0) {
		push @work_set, shift @dist_or_mods;
		$i--;
	    }
	    if ($rr) {
		@work_set = reverse @work_set;
	    }
	}
	
	my $log_preamble = "$perl: $work_set[0] .. $work_set[-1]";
	if ($logfh) {
	    print $logfh "[" . scalar(localtime) . "] $log_preamble BEGIN\n";
	}
	my $std_title = "smoke($tty): $perl";
	xterm_config('-title', $std_title);

	if ($prefs_dir && -d $prefs_dir && -r "$prefs_dir/SlayMakefile") {
	    save_pwd {
		if (chdir $prefs_dir) {
		    my @cmd = qw(slaymake);
		    system(@cmd);
		    if ($? != 0) {
			die "Error while executing <@cmd>";
		    }
		}
	    };
	}

	my $cpan_shell_init = "";
	$cpan_shell_init .= q#{ package CPAN::SRTShell; @ISA = $CPAN::Frontend; sub mysleep { shift; sleep shift()/10 }} $CPAN::Frontend="CPAN::SRTShell";#;
	if ($do_action eq 'test') {
	    if ($^O ne 'MSWin32') { # somehow does not work under Windows
		$cpan_shell_init .= q{$CPAN::VERSION >= 1.9205 or warn(("*"x70)."\n*** Old CPAN version $CPAN::VERSION\n".("*"x70)."\n"); };
	    }
	    $cpan_shell_init .= q{CPAN::HandleConfig->load; $CPAN::Config->{test_report}=1; $CPAN::Config->{urllist}=[qw(ftp://ftp.funet.fi/pub/CPAN/)]; $CPAN::FTP::connect_to_internet_ok=1; };
	} else {
	    $cpan_shell_init .= "";
	}
	$cpan_shell_init .= q{eval { require Expect; 1 } or $ENV{PERL_EXTUTILS_AUTOINSTALL}=q{--defaultdeps}; };
	if ($use_sqlite) {
	    $cpan_shell_init .= q#if (eval { require CPAN::SQLite; 1; }) { $CPAN::Config->{use_sqlite}=1; } else { $CPAN::Config->{cache_metadata}=1; } #;
	} else {
	    $cpan_shell_init .= q#$CPAN::Config->{use_sqlite}=0; $CPAN::Config->{cache_metadata}=1; #;
	}
	if ($build_dir_reuse) {
	    my $build_reuse_dir = "build_reuse_$perl";
	    $build_reuse_dir =~ s{/}{_}g;
	    $build_reuse_dir = "/usr/local/src/CPAN/$build_reuse_dir";
	    mkdir $build_reuse_dir if !-d $build_reuse_dir;
	    die "Cannot use $build_reuse_dir" if !-d $build_reuse_dir || !-w $build_reuse_dir;
	    $cpan_shell_init .= q{$CPAN::Config->{build_dir_reuse} = 1; $CPAN::Config->{build_dir} = "}.$build_reuse_dir.q{"; };
	}
	my @cmd = ($perl);
 	if ($perl =~ /5\.6\.2/ || $perl =~ /5\.005/) {
	    # Preload to avoid segfaults
	    push @cmd, "-MFile::HomeDir";
 	}
	push @cmd, ("-MCPAN", "-e");
	if ($has_xterm_config) {
	    my $dist_or_mods_line = "";
	    for my $dist (@work_set) {
		$dist_or_mods_line .= qq{system(qq{xterm-config -title "$std_title $dist"}); $do_action(qq{$dist}); };
	    }
	    push @cmd, $cpan_shell_init . $dist_or_mods_line;
	} else {
	    my $dist_or_mods_line = join(", ", map { qq{qq{$_}} } @work_set);
	    push @cmd, $cpan_shell_init . $do_action.qq{($dist_or_mods_line)};
	}

	if (is_in_path("nice") && $^O ne 'MSWin32') {
	    unshift @cmd, "nice";
	}
	if (is_in_path("limits") && $^O ne 'MSWin32') {
	    # on my FreeBSD system, kern.maxfiles is ~ 12000
	    unshift @cmd, "limits", "-d", 500*1024*1024;#, "-n", 4000;
	}
	if ($n) {
	    unshift @cmd, "echo";
	}
	print STDERR "# @cmd\n";
	local %ENV = %ENV;
	if ($batch) {
	    #$ENV{PERL_MM_USE_DEFAULT} = 1; --- currently bad idea ... turns CPAN::Reporter questions off
	    $ENV{PERL_EXTUTILS_AUTOINSTALL}=q{--defaultdeps};
	}
	system @cmd;
	if ($? & 127) {
	    die sprintf("Child died with signal %d, %s coredump\n",
			($? & 127),  ($? & 128) ? 'with' : 'without');
	}
	if ($logfh) {
	    print $logfh "[" . scalar(localtime) . "] $log_preamble DONE\n";
	}
    }
}

if ($do_continue && @dist_or_mods) {
    open my $ofh, ">>", $cpan_smoke_last
	or die "Cannot write to $cpan_smoke_last: $!";
    my $last_dist = $r ? $dist_or_mods[-1] : $dist_or_mods[0];
    print $ofh $last_dist, "\n"
	or die $!;
    close $ofh
	or die $!;
}

if ($wait) {
    print STDERR "Smoking finished, enter RETURN to exit: ";
    <STDIN>;
}

END {
    if (defined $idletermchecker_pid) {
	kill KILL => $idletermchecker_pid;
	if (time-$start_time>60 && is_in_path("tkmessage")) {
	    print STDERR "Smoking finished.\n";
	    system("tkmessage", "-bg", "green", "-fg", "black", "Smoking finished");
	}
    }
}

sub xterm_config {
    my(@args) = @_;
    if (!defined $has_xterm_config) {
	$has_xterm_config = is_in_path("xterm-config") ? 1 : 0;
    }
    return if (!$has_xterm_config);
    my @cmd = ("xterm-config", @args);
    system @cmd;
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/work/srezic-repository 
# REPO MD5 81c0124cc2f424c6acc9713c27b9a484

sub is_in_path {
    my($prog) = @_;
    return $prog if (file_name_is_absolute($prog) and -f $prog and -x $prog);
    require Config;
    %Config::Config = %Config::Config if 0; # cease -w
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"
		if (-x "$_\\$prog.bat" ||
		    -x "$_\\$prog.com" ||
		    -x "$_\\$prog.exe" ||
		    -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/work/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8

BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

# REPO BEGIN
# REPO NAME save_pwd /home/e/eserte/work/srezic-repository 
# REPO MD5 0f7791cf8e3b62744d7d5cfbd9ddcb07

=head2 save_pwd(sub { ... })

=for category File

Save the current directory and assure that outside the block the old
directory will still be valid.

=cut

sub save_pwd (&) {
    my $code = shift;
    require Cwd;
    my $pwd = Cwd::cwd();
    eval {
	$code->();
    };
    my $err = $@;
    chdir $pwd or die "Can't chdir back to $pwd: $!";
    die $err if $err;
}
# REPO END

__END__

=head1 NAME

cpan_smoke_modules - test and report CPAN modules with more perls

=head1 SYNOPSIS

    cpan_smoke_modules module1 author/distribution.tar.gz ...

=head1 DESCRIPTION

=head2 OPTIONS

=over

=item -n

Dry run.

=item -perl I<executable> [-perl ...]

Specify which perl to use. Can be specified multiple times.

=item -pv I<version>,I<version>,...

This is the short version of the B<-perl> option. Use the perl
versions, separated by commas.

=item -allperls

Use more perls than the standard four (5.00505, 5.6.2, 5.8.8, 5.10.0).
This includes for instance threaded perls.

=item -install

Do not only test, but also install.

=item -continue

Fetch the RECENT distributions list from a CPAN site and continue from
an earlier smoke. This uses the last distribution listed in F<<
~/.cpan_smoke_modules_<$archname>.last >> as an anchor point.

=item -recent

Fetch the RECENT distributions list from a CPAN site and smoke them
all.

=item -interactive

Together with B<-continue> or B<-recent>: ask first before starting
the smoke.

=item -reverse

Reverse the list of modules/distributions to test, used in conjunction
with B<-continue> or B<-recent>.

=item -[no]sqlite

Use/do not use L<CPAN::SQLite>. On by default. If CPAN::SQLite is not
available, then the normal non-sqlite internal storage will be used.

=item -fl I<file>

Specify a file with the listed distributions/modules.

=imte -builddirreuse

set the build_dir_reuse flag of CPAN.pm. Not well tested.

=item -warntimeout I<seconds>

Seconds to wait before showing the warn dialog. Default is 60 seconds.

=back

=head1 NOTES

Assumption is that distributions are sorted in reverse order, that is
newest first. Any later distribution version on the command line will
be removed from the list.

    
=head1 TODO

    * evtl. die recent-Liste http://search.cpan.org/recent automatisch
      holen und abarbeiten, dabei aber Duplikate (ältere Versionen)
      ignorieren (-> CPAN::DistInfo?)

    * evtl. auch das zuletzt getestete Modul merken und/oder
      ~/.cpanreporter/reports-sent.db verwenden, um zu sehen, welche
      Dists getestet werden müssen (leider sind dort die disabled=1
      markierten Dists nicht enthalten)

=head1 AUTHOR

Slaven ReziE<0x0107>

=cut
