#!/usr/bin/perl
# -*- perl -*-

#
# Copyright (C) 2008,2009,2016 Slaven Rezic All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#

=head1 NAME

pm-to-deb - return debian package names for perl modules

=head1 SYNOPSIS

    $ pm-to-deb DBI DBD::mysql Template Kwalify Does::Not::Exist
    Cannot find package for Does::Not::Exist
    libdbd-mysql-perl
    libdbi-perl
    libkwalify-perl
    libtemplate-perl

You can also use the C<-fast> switch, but in this case there's no
report for missing packages. And it needs L<Regexp::Assemble>.

In a CPAN distribution directory it's possible to get the requirements
from the F<META.yml> file:

    $ pm-to-deb --from-meta

Or more accurate, after a C<perl Makefile.PL> or C<perl Build.PL> a
F<MYMETA.yml> file is usually available which also has I<dynamic>
prereqs listed:

    $ pm-to-deb --from-mymeta

=cut

use strict;
use warnings;
our $VERSION = '2.01';

use File::Basename 'dirname';
use File::Spec;
use Getopt::Long;

my $sources_list;
my $fast;
my $direct;
my $v;
my $all;
my $from_mymeta;
my $from_meta;
my @contents_files;
GetOptions("fast!" => \$fast,
           "direct!" => \$direct,
           "sources-list|s=s" => \$sources_list,
           "v" => \$v,
           "all" => \$all,
           'from-mymeta' => \$from_mymeta,
           'from-meta' => \$from_meta,
           'contents-file=s@' => \@contents_files,
          )
    or die "usage: $0 [--sources-list ...] [-fast] [-all] [-v] ...";

my @modules;
if ($from_mymeta) {
    push @modules, load_requires('MYMETA.yml');
}
if ($from_meta) {
    warn "WARNING: you specified --from-mymeta AND --from-meta, which is not very useful. Still continuing...\n";
    push @modules, load_requires('META.yml');
}

push @modules, @ARGV;
@modules
    or die <<EOF;
Please specify one or more module names, or
use the --from-mymeta or --from-meta switches
if in a CPAN distribution directory.
EOF

my $locator;
my @cmd;
## dlocate only works for *installed* packages
#if (!is_in_path("dlocate")) {
#    if (!is_in_path("apt-file")) {
#        die "Neither dlocate nor apt-file are installed, cannot proceed.\n";
#    } else {
#        warn "dlocate is not available, fallback to slower apt-file.\n";
	if (!is_in_path("apt-file")) {
	    die "Please install apt-file first.\n";
        }
        $locator = 'apt-file';
        @cmd = ('apt-file');
	if (defined $sources_list) {
            push @cmd, '--sources-list', $sources_list;
        }
        push @cmd, ('search', '--regexp');
#    }
#} else {
#    $locator = 'dlocate';
#    @cmd = ('dlocate', '--');
#}

my %seen_package;

my @my_INC = map {
    # perl's @INC may say .../5.10 (which is just a symlink), while
    # apt-file says .../5.10.0
    my $dir = $_;
    my $l = readlink $dir;
    if (defined $l) {
        $l = File::Spec->rel2abs($l, dirname $dir);
        if ($l eq $dir) {
            undef $l;
        }
    }
    ($dir, (defined $l ? $l : ()));
} grep {
    $_ ne '.' && $_ ne '/etc/perl'
} @INC;

if ($fast) {
    my $regexp = make_regexp(@modules);
    my @packages = find_packages_for_regexp($regexp);
    print map { "$_\n" } sort @packages;
} elsif ($direct) {
    my $prefix_rx = "^(?:" . join("|", map { quotemeta(substr($_, 1)) } @my_INC) . ")/";
    my %capture_to_module;
    my $regexp = do {
        my $i = 0;
        $prefix_rx . '(' . join('|', map {
            ++$i;
            $capture_to_module{'m'.$i} = $_;
            my $module_file = module_to_file($_);
            "(?<m$i>" . quotemeta($module_file) . ')';
        } @modules) . ')';
    };
    $regexp = qr{$regexp};
    my %seen_module;
    if (!@contents_files) {
        require File::Glob;
        @contents_files = File::Glob::bsd_glob("$ENV{HOME}/.cache/apt-file/*_Contents-amd64.gz"); # XXX use archname!!!
    }
    my @packages; my %seen_package; # don't want to depend on Tie::IxHash
    for my $file (@contents_files) {
        open my $fh, '-|', 'zcat', $file or die $!;
        while(<$fh>) {
            last if /^FILE\s+LOCATION$/;
        }
        while(<$fh>) {
            if ($_ =~ $regexp) {
                for my $capture (keys %+) {
                    $seen_module{$capture_to_module{$capture}} = 1;
                }
                my($location) = $_ =~ m{.*/(.*)};
                push @packages, $location
                    if !$seen_package{$location}++;
            }
        }
    }
    for my $package (@packages) {
        print $package, "\n";
    }
    my $not_found_count = 0;
    for my $module (@modules) {
        if (!$seen_module{$module}) {
            warn "Cannot find package for $module\n";
            $not_found_count++;
            if ($not_found_count > 126) {
                $not_found_count = 126;
            }
        }
    }
    exit $not_found_count;
} else {
    my $not_found_count = 0;
    for my $module (@modules) {
        my $module_file = module_to_file($module);

        # ?: is only needed for apt-file < 2.1.0
        my $regexp;
        if ($locator eq 'apt-file') {
            $regexp = "(?:" . join("|", map { substr($_, 1) } @my_INC) . ")/$module_file";
        } elsif ($locator eq 'dlocate') {
            $regexp = "("   . join("|", map { substr($_, 1) } @my_INC) . ")/$module_file";
        } else {
            die "Locator <$locator>?";
        }

        my @packages = find_packages_for_regexp($regexp);

        if (!@packages) {
            warn "Cannot find package for $module\n";
            $not_found_count++;
        } else {
            print map { "$_\n" } grep { !$seen_package{$_}++ } sort @packages;
        }
    }
    #print join("\n", sort keys %package), "\n";
    exit $not_found_count;
}

sub find_packages_for_regexp {
    my $regexp = shift;

    my %new_package;

    open my $fh, "-|", @cmd, $regexp
        or die $!;
    while(<$fh>) {
        chomp;
        my($pack, $file) = split /\s*:\s*/;
        $new_package{$pack}++;
    }

    if (!$all) {
        remove_conflicting_packages(\%new_package);
    }

    keys %new_package;
}

# Hardcoded list of conflicting packages.
sub remove_conflicting_packages {
    my $packages_ref = shift;
    my @remove;
    if (exists $packages_ref->{'perlmagick'} &&
        exists $packages_ref->{'graphicsmagick-libmagick-dev-compat'}) {
        push @remove, 'graphicsmagick-libmagick-dev-compat';
    }
    if (exists $packages_ref->{'libgd-gd2-perl'}) {
        for my $package (qw(libgd-gd1-noxpm-perl libgd-gd1-perl libgd-gd2-noxpm-perl)) {
            if (exists $packages_ref->{$package}) {
                push @remove, $package;
            }
        }
    }
    if (exists $packages_ref->{'libtext-csv-xs-perl'} &&
        exists $packages_ref->{'libtext-csv-perl'}) {
        push @remove, 'libtext-csv-perl';
    }
    if (exists $packages_ref->{'libcatalyst-perl'} &&
        exists $packages_ref->{'libcatalyst-modules-perl'}) {
        push @remove, 'libcatalyst-perl';
    }
    for my $package (@remove) {
        if ($v) {
            warn "NOTE: deleting $package.\n";
        }
        delete $packages_ref->{$package};
    }
}

sub module_to_file {
    my $module = shift;
    (my $module_file = $module) =~ s{::}{/}g;
    $module_file .= ".pm";
    $module_file;
}

sub load_requires {
    my $file = shift;
    require YAML;
    my $d = YAML::LoadFile($file);
    sort keys %{ $d->{requires} || {} };
}

sub make_regexp {
    my(@modules) = @_;
    my @module_files = map { module_to_file($_) } @modules;
    my $prefix_rx = "(?:" . join("|", map { substr($_, 1) } @my_INC) . ")/";
    require Regexp::Assemble;
    my $ra = Regexp::Assemble->new;
    for my $module_file (@module_files) {
        $ra->add($prefix_rx . quotemeta($module_file));
    }
    my $regexp = $ra->re;
    $regexp;
}

=head1 BUGS

 * It is possible that a module is provided by more than one package.
   There's a list of some of these conflicting packages
   (Image::Magick, GD), but possibly more are missing.

 * It's not very fast.

=head1 TODO

 * It would be nice that in the case of conflicting modules, already
   installed packages would be preferred. This would be useful if the
   generated list is used for installing packages on the current host,
   but not for generating package lists for meta packages or so.

=head1 AUTHOR

Slaven Rezic

=head1 SEE ALSO

L<apt-file(1)>.

=cut

######################################################################
# Repository helpers

# REPO BEGIN
# REPO NAME is_in_path /home/slavenr/work2/srezic-repository 
# REPO MD5 e18e6687a056e4a3cbcea4496aaaa1db
sub is_in_path {
    my($prog) = @_;
    if (file_name_is_absolute($prog)) {
	if ($^O eq 'MSWin32') {
	    return $prog       if (-f $prog && -x $prog);
	    return "$prog.bat" if (-f "$prog.bat" && -x "$prog.bat");
	    return "$prog.com" if (-f "$prog.com" && -x "$prog.com");
	    return "$prog.exe" if (-f "$prog.exe" && -x "$prog.exe");
	    return "$prog.cmd" if (-f "$prog.cmd" && -x "$prog.cmd");
	} else {
	    return $prog if -f $prog and -x $prog;
	}
    }
    require Config;
    %Config::Config = %Config::Config if 0; # cease -w
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"     if (-f "$_\\$prog" && -x "$_\\$prog");
	    return "$_\\$prog.bat" if (-f "$_\\$prog.bat" && -x "$_\\$prog.bat");
	    return "$_\\$prog.com" if (-f "$_\\$prog.com" && -x "$_\\$prog.com");
	    return "$_\\$prog.exe" if (-f "$_\\$prog.exe" && -x "$_\\$prog.exe");
	    return "$_\\$prog.cmd" if (-f "$_\\$prog.cmd" && -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/slavenr/work2/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8
BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

# Local Variables:
# mode: cperl
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
# vim:sw=4:ts=8:sta:et
