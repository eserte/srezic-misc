#!/usr/bin/perl -w
# -*- perl -*-

#
# $Id: idletermchecker,v 1.13 2007/11/29 20:59:20 eserte Exp $
# Author: Slaven Rezic
#
# Copyright (C) 2007 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

# Obsolete comments:
#   On FreeBSD:
#     kldload snp
#     sudo watch p2 | idlechecker.pl
#   On Linux:
#     Use snoop? http://sourceforge.net/projects/snoop/

use strict;
use File::Spec;
use IO::Select;
use Getopt::Long;

my @terminals;
my $timeout = 30; # mx.develooper.com is sloooow!
my $local_timeout;
my $q; # be quiet on stderr
GetOptions("timeout=i" => \$timeout,
	   "q" => \$q,
	  )
    or die "usage!";

if (@ARGV) {
    @terminals = map { abbrev_to_dev($_) } @ARGV;
    check_terminals(\@terminals);
} else {
    check_stdin();
}

sub check_terminals {
    my($terminals_ref) = @_;
    my @terminals = @$terminals_ref;
    while() {
	my @timeouted;
	my $use_timeout = $local_timeout || $timeout;
	for my $terminal (@terminals) {
	    my($mtime) = (stat($terminal))[9];
	    if (!defined $mtime) {
		die "Cannot get mtime for <$terminal>";
	    }
	    if (time-$mtime >= $use_timeout) {
		push @timeouted, $terminal;
	    }
	}
	if (@timeouted) {
	    my $message = "No output anymore on terminal(s) <@timeouted> for $use_timeout seconds!";
	    my $do_exit = exit_dialog($message);
	    if ($do_exit) {
		my %timeouted = map {($_,1)} @timeouted;
		my @new_terminals;
		for (@terminals) {
		    push @new_terminals, $_ if !$timeouted{$_};
		}
		if (!@new_terminals) {
		    exit 0;
		} else {
		    @terminals = @new_terminals;
		}
	    }
	}
	sleep 1;
    }
}

sub check_stdin {
    my $s = IO::Select->new;
    $s->add(\*STDIN);

    while () {
	while () {
	    my @ready = $s->can_read($timeout);
	    if (!@ready) {
		last;
	    }
	    while () {
		my $buf;
		last if sysread(STDIN, $buf, 256, 0) < 256;
	    }
	}
	my $message = "No output anymore on terminal for $timeout seconds!";
	my $do_exit = exit_dialog($message);
	exit 0 if $do_exit;
    }
}

sub exit_dialog {
    my($message) = @_;
    undef $local_timeout;
    if (!$q) {
	print STDERR "$message\n";
    }

    if (is_in_path("alarm")) {
	system("alarm", "-nicedown");
    }
    if (is_in_path("tkmessage")) {
	system("tkmessage", "-bg", "red", "-fg", "white", "-buttons", "Continue:100,Abort:101,Later 1min:102,Later 5min:103,Later 30min:104", $message);
	my $st = $?/256;
	if ($st >= 102 && $st <= 104) {
	    $local_timeout = {102 => 1*60,
			      103 => 5*60,
			      105 =>30*60,
			     }->{$st};
	    return 0;
	} elsif ($st != 100) {
	    return 1;
	} else {
	    return 0;
	}
    } else {
	print STDERR "$message. Abort? (y/N) ";
	chomp(my $yn = <STDIN>);
	if ($yn =~ m{^y}) {
	    return 1;
	} else {
	    return 0;
	}
    }
}

sub abbrev_to_dev {
    my $abbrev = shift;
    if (File::Spec->file_name_is_absolute($abbrev)) {
	$abbrev;
    } elsif ($^O eq 'linux') {
	"/dev/pts/$abbrev";
    } else {
	"/dev/tty$abbrev";
    }
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/work/srezic-repository 
# REPO MD5 c9844dc5bfa1798245e913b3e53ba4e1

=head2 is_in_path($prog)

=for category File

Return the pathname of $prog, if the program is in the PATH, or undef
otherwise.

DEPENDENCY: file_name_is_absolute

=cut

sub is_in_path {
    my($prog) = @_;
    return $prog if (file_name_is_absolute($prog) and -f $prog and -x $prog);
    require Config;
    %Config::Config = %Config::Config if 0; # cease -w
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"
		if (-x "$_\\$prog.bat" ||
		    -x "$_\\$prog.com" ||
		    -x "$_\\$prog.exe" ||
		    -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/work/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8

=head2 file_name_is_absolute($file)

=for category File

Return true, if supplied file name is absolute. This is only necessary
for older perls where File::Spec is not part of the system.

=cut

BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

__END__
