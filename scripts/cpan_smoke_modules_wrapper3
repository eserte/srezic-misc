#!/usr/bin/perl

use strict;
use FindBin;
use Getopt::Long;

sub run_smoker ($$$);
sub spec_usage (;$);
sub maybe_xterm_conf ($);

my $do_maintperl;
my @specs;
my $mirror_url = "http://cpan.cpantesters.org/";
my $min_build_dir_avail;
my $scripts_dir = $FindBin::RealBin;
my $cpan_smoke_modules_options;
my $scenario;
my @scenario_modules;

sub usage () {
    die <<EOF;
usage: $0 [-mirrorurl ...] [-maintperl | -spec perlver,stableness,daterange]
EOF
}

GetOptions(
	   "maintperl" => \$do_maintperl,
	   "mirrorurl=s" => \$mirror_url,
	   'spec=s@'     => \@specs,
	   "minbuilddiravail=s" => \$min_build_dir_avail,
	   "cpansmokemodulesoptions=s" => \$cpan_smoke_modules_options,
	   "scenario=s" => \$scenario,
	  )
    or usage;
if ($scenario) {
    @scenario_modules = @ARGV;
    if (!@scenario_modules) {
	die "No modules given for scenario '$scenario'";
    }
} else {
    @ARGV and usage;
}

my $recent_url = $mirror_url;

if (!$do_maintperl && !@specs && !$scenario) {
    die "Please specify either -maintperl or -spec or -scenario";
}

if ($scenario) {
    my $scenario_args;
    if ($scenario =~ m{^(.*?),(.*)}) {
	($scenario, $scenario_args) = ($1, $2);
    }
    my $sub = 'scenario_' . $scenario;
    if (defined &$sub) {
	no strict 'refs';
	&$sub($scenario_args);
    } else {
	die "Invalid scenario '$scenario'\n";
    }
} elsif (@specs) {
    # First expand perl versions {5.8.9,5.10.1,...}
    my @new_specs;
    for my $spec (@specs) {
	if ($spec =~ m<^\{(.*)\}(.*)>) {
	    my($perlvers,$rest) = ($1,$2);
	    for my $perlver (split /,/, $perlvers) {
		push @new_specs, "$perlver$rest";
	    }
	} else {
	    push @new_specs, $spec;
	}
    }
    @specs = @new_specs;

    # Then check
    for my $spec (@specs) {
	my($perlver, $stableness, $range) = split /,/, $spec;
	spec_usage if !defined $range;
	spec_usage("perl version in '$spec' does not look like expected") if $perlver !~ m{^\d+\.\d+\.}; # does not look like a perl version (be not to strict here)
	spec_usage("stableness in '$spec' must be 'stable' or 'devel'") if $stableness !~ m{^(devel|stable)$};
	spec_usage("time range in '$spec' does not look like '-\${DAYS}d'") if $range !~ m{^-\d+.*};
    }

    for my $spec (@specs) {
	my($perlver, $stableness, $range) = split /,/, $spec;
	maybe_xterm_conf "INIT cpan_smoke_modules wrapper";
	run_smoker $perlver, $stableness, $range;
	maybe_xterm_conf "FINISHED cpan_smoke_modules wrapper";
    }
} elsif ($do_maintperl) {
    # installs everything stable and tests also developer versions
    maybe_xterm_conf "INIT maintperl";

    (getpwuid($<))[0] eq 'cpansand'
    	or die "Works only for cpansand!";

    run_smoker '5.20.0', 'stable', '-14d';
    run_smoker '5.20.0', 'devel', '-3d';

    run_smoker '5.18.2', 'stable', '-14d';
    run_smoker '5.18.2', 'devel', '-3d';

    run_smoker '5.16.3t', 'stable', '-14d';
    run_smoker '5.16.3t', 'devel', '-3d';

    run_smoker '5.14.4', 'stable', '-14d';
    run_smoker '5.14.4', 'devel', '-3d';

    run_smoker '5.10.1', 'stable', '-14d';
    run_smoker '5.10.1', 'devel', '-3d';

    run_smoker '5.8.9', 'stable', '-14d';
    run_smoker '5.8.9', 'devel', '-3d';

    maybe_xterm_conf "FINISHED maintperl";
}

sub run_smoker ($$$) {
    my($perl_version, $stability, $interval) = @_;
    warn "*** $perl_version: Just test uploads last $interval, " . ($stability eq 'stable' ? 'only stable' : 'also devel') . " versions...\n";
    my $perl_exe;
 FIND_PERL: {
	for my $prefix ('/usr/perl', '/opt/perl-') {
	    my $try_perl_exe;
	    $try_perl_exe = $prefix . $perl_version . '/bin/perl' . $perl_version;
	    if (-x $try_perl_exe) {
		$perl_exe = $try_perl_exe;
		last FIND_PERL;
	    }
	    $try_perl_exe = $prefix . $perl_version . '/bin/perl';
	    if (-x $try_perl_exe) {
		$perl_exe = $try_perl_exe;
		last FIND_PERL;
	    }
	}
	my $try_perl_exe = '/usr/local/bin/perl' . $perl_version;
	if (-x $try_perl_exe) {
	    $perl_exe = $try_perl_exe;
	    last FIND_PERL;
	}
    }
    if (!$perl_exe) {
	die "Cannot find a perl $perl_version, tried in /usr/perlXXX, /opt/perl-XXX and $perl_exe";
    }
    my $install_arg = ($stability eq 'stable' ? '-install' : '');
    #my $install_arg = ''; # never install, currently running as non-cpansand with sudo configured
    my $cmd = q{env PERL_BATCH=yes } . $scripts_dir . q{/cpan_smoke_modules};
    $cmd .= q{ } . $cpan_smoke_modules_options if defined $cpan_smoke_modules_options;
    $cmd .= q{ -savereports -typescript -nosignalend -skiptested -r };
    $cmd .= $install_arg;
    $cmd .= q{ -perl } . $perl_exe;
    $cmd .= q{ -mirrorurl } . $mirror_url;
    if ($min_build_dir_avail) {
	$cmd .= q{ -minbuilddiravail } . $min_build_dir_avail;
    }
    $cmd .= q{ -- `};
    if (0) { # just looking at the distribution name to decide whether
             # it's stable or not
	$cmd .= $scripts_dir . q{/cpan_recent_uploads2 -onlydists -url } . $recent_url . q{ -from } . $interval . q{ -to -2m -v } . ($stability eq 'stable' ? '-stable' : '') . q{ | grep -v '\.pl$'};
    } else { # checking the CPAN index to decide whether it's stable
             # or not (but the index is sometimes somewhat slow)
	$cmd .= $scripts_dir . q{/cpan_recent_uploads2 -onlydists -url } . $recent_url . q{ -from } . $interval . q{ -v } . ($stability eq 'stable' ? '-indexed' : '');
    }
    $cmd .= q{`};
    warn "$cmd ...\n";
    system $cmd;
    if ($? == 2) {
	die "SIGINT";
    }
}

sub scenario_locale {
    my $basecmd = _scenario_basecmd();
    {
	warn "env LC_ALL=C $basecmd ...\n";
	local $ENV{LC_ALL} = 'C';
	system $basecmd;
	die "SIGINT" if ($? == 2);
    }
    {
	warn "env LC_ALL=de_DE.UTF-8 $basecmd ...\n";
	local $ENV{LC_ALL} = 'de_DE.UTF-8';
	system $basecmd;
	die "SIGINT" if ($? == 2);
    }
}

sub scenario_hashrandomization {
    my $basecmd = _scenario_basecmd();
    for my $pass (1..2) # simply call twice, in the hope that we
                        # have both pass and fail. Theoretically we
                        # could restrict to >= 5.17.6
    {
	warn "(pass $pass) $basecmd ...\n";
	system $basecmd;
	die "SIGINT" if ($? == 2);
    }
}

sub scenario_prereq {
    my $scenario_args = shift;
    if (!defined $scenario_args || !length $scenario_args) {
	die "Please specify prereq modules: --scenario=prereq,Module::A,Module::B\n";
    }
    my @prereqs = split /,/, $scenario_args;
    my $basecmd = _scenario_basecmd();
    {
	my $cmd = $basecmd . ' ' . join(' ', map { "-pre $_" } @prereqs);
	warn "(with prereqs) $cmd ...\n";
	system $cmd;
	die "SIGINT" if ($? == 2);
    }
    {
	warn "(without prereqs) $basecmd ...\n";
	system $basecmd;
	die "SIGINT" if ($? == 2);
    }
}

sub scenario_testpod {
    _scenario_hidemod('Test::Pod');
}

sub scenario_testpodcoverage {
    _scenario_hidemod('Test::Pod::Coverage');
}

sub scenario_testperlcritic {
    _scenario_hidemod('Test::Perl::Critic');
}

sub scenario_testsignature {
    _scenario_hidemod_and_prereq('Test::Signature');
}

sub _scenario_hidemod {
    my $hidemod = shift;
    my $basecmd = _scenario_basecmd();
    {
	my $cmd = $basecmd . ' -hidemod ' . $hidemod;
	warn "(with hidden $hidemod) $cmd ...\n";
	system $cmd;
	die "SIGINT" if ($? == 2);
    }
    {
	warn "(without hidden $hidemod) $basecmd ...\n";
	system $basecmd;
	die "SIGINT" if ($? == 2);
    }
}

sub _scenario_hidemod_and_prereq {
    my $hidemod = shift;
    my $basecmd = _scenario_basecmd();
    {
	my $cmd = $basecmd . ' -hidemod ' . $hidemod;
	warn "(with hidden $hidemod) $cmd ...\n";
	system $cmd;
	die "SIGINT" if ($? == 2);
    }
    {
	my $cmd = $basecmd . ' -pre ' . $hidemod;
	warn "(with installed $hidemod) $basecmd ...\n";
	system $basecmd;
	die "SIGINT" if ($? == 2);
    }
}

sub _scenario_basecmd {
    my $basecmd = q{env PERL_BATCH=yes } . $scripts_dir . q{/cpan_smoke_modules};
    $basecmd .= q{ -nosignalend};
    $basecmd .= q{ } . $cpan_smoke_modules_options if defined $cpan_smoke_modules_options;
    $basecmd .= q{ } . join(' ', @scenario_modules);
    $basecmd;
}

sub spec_usage (;$) {
    my $msg = shift;
    die "ERROR: " . ($msg ? "$msg\n\n" : '') .
	"spec format is perlversion,stableness,daterange where
perlversion is something like '5.18.2'
stableness is either 'devel' or 'stable'
daterange is amount of days written as '-20d'
";
}

sub maybe_xterm_conf ($) {
    my $title = shift;
    our $HAVE_XTERM_CONF;
    if (!defined $HAVE_XTERM_CONF) {
	$HAVE_XTERM_CONF = is_in_path('xterm-conf') ? 1 : 0;
    }
    return if !$HAVE_XTERM_CONF;
    system('xterm-conf', '-f', '-title', $title);
}

# REPO BEGIN
# REPO NAME is_in_path /home/e/eserte/src/srezic-repository 
# REPO MD5 e18e6687a056e4a3cbcea4496aaaa1db

sub is_in_path {
    my($prog) = @_;
    if (file_name_is_absolute($prog)) {
	if ($^O eq 'MSWin32') {
	    return $prog       if (-f $prog && -x $prog);
	    return "$prog.bat" if (-f "$prog.bat" && -x "$prog.bat");
	    return "$prog.com" if (-f "$prog.com" && -x "$prog.com");
	    return "$prog.exe" if (-f "$prog.exe" && -x "$prog.exe");
	    return "$prog.cmd" if (-f "$prog.cmd" && -x "$prog.cmd");
	} else {
	    return $prog if -f $prog and -x $prog;
	}
    }
    require Config;
    %Config::Config = %Config::Config if 0; # cease -w
    my $sep = $Config::Config{'path_sep'} || ':';
    foreach (split(/$sep/o, $ENV{PATH})) {
	if ($^O eq 'MSWin32') {
	    # maybe use $ENV{PATHEXT} like maybe_command in ExtUtils/MM_Win32.pm?
	    return "$_\\$prog"     if (-f "$_\\$prog" && -x "$_\\$prog");
	    return "$_\\$prog.bat" if (-f "$_\\$prog.bat" && -x "$_\\$prog.bat");
	    return "$_\\$prog.com" if (-f "$_\\$prog.com" && -x "$_\\$prog.com");
	    return "$_\\$prog.exe" if (-f "$_\\$prog.exe" && -x "$_\\$prog.exe");
	    return "$_\\$prog.cmd" if (-f "$_\\$prog.cmd" && -x "$_\\$prog.cmd");
	} else {
	    return "$_/$prog" if (-x "$_/$prog" && !-d "$_/$prog");
	}
    }
    undef;
}
# REPO END

# REPO BEGIN
# REPO NAME file_name_is_absolute /home/e/eserte/src/srezic-repository 
# REPO MD5 89d0fdf16d11771f0f6e82c7d0ebf3a8

BEGIN {
    if (eval { require File::Spec; defined &File::Spec::file_name_is_absolute }) {
	*file_name_is_absolute = \&File::Spec::file_name_is_absolute;
    } else {
	*file_name_is_absolute = sub {
	    my $file = shift;
	    my $r;
	    if ($^O eq 'MSWin32') {
		$r = ($file =~ m;^([a-z]:(/|\\)|\\\\|//);i);
	    } else {
		$r = ($file =~ m|^/|);
	    }
	    $r;
	};
    }
}
# REPO END

__END__

=head1 NAME

cpan_smoke_modules_wrapper3 - call L<cpan_smoke_modules> with module lists

=head1 SYNOPSIS

    cpan_smoke_modules_wrapper3 -spec 5.18.2,stable,-1d -mirrorurl http://cpan.develooper.com --cpansmokemodulesoptions="-vnc"
    cpan_smoke_modules_wrapper3 -spec "{5.18.2,5.19.11},devel,-1d"

=head1 DESCRIPTION

B<cpan_smoke_modules_wrapper3> creates lists of recently uploaded CPAN
modules, runs tests against these modules for specified perl versions,
and optionally installs them.

Specification of what should be tested is done with one or more
C<-spec> options. A spec is a string with a comma-separated triple:

=over

=item * a perl version specified as I<5.X.Y> (for example C<5.19.11>)
or a list of perl versions specified like this: C<{5.X.Y,5.A.B,5.C.D}>

=item * the "stableness" type (C<devel> or C<stable>)

=item * a day range specified as C<-I<days>d> (for example C<-1d>)

=back

For stableness=C<stable> only "stable" distributions (non-TRIAL and
non-underscore) are tested _and_ installed. For stableness=C<devel>
all distributions are tested but not installed.

More options can be passed to L<cpan_smoke_modules> using the
C<-cpansmokemodulesoptions> switch.

=head1 BUGS

The module list is passed via command line parameters and is subject
to operating system limits. The module list produced with "-1000d" may
work on Linux systems, but much larger values do not.

=cut
