=head1 CPAN in a nutshell

=head1 Data and Data Types

=head2 List/Array modules

Handy utility functions can be found in the core module (since 5.7.3)
L<List::Util>. Functions missing in this module are gathered in the
CPAN module L<List::MoreUtils>. This module also obsoletes the CPAN
modules L<List::MoreUtil> and L<List::Utils>.

=head2 Serialization

Before choosing a serialization module, one needs to choose a
serialization format first. Some differences in the formats are:

=over

=item Completeness of serialization

Some serialization formats target to be able to serialize B<all>
aspects of Perl. All serialization formats can handle the basic types
(scalars, lists, hashes), but for other types (regexps, blessed
objects, even code references) on needs to choose either a
Perl-generating serializer (e.g. L<Data::Dumper>), a YAML-generating
serializer, or Storable. Particularly the Bencode and JSON formats are
not capable to handle all Perl types.

=item Inter-language interaction

If the serialization data should be passed to other programming
languages, then a standardized serialization format like YAML, JSON,
or Bencode should be used. Especially the output of Data::Dumper (pure
perl) is not suited, so is probably not Storable (deserializers
probably do not exist outside the Perl world). While XML is a
standard, there's probably no standard for serializing data structures
into XML data.

=item Readability for humans

Most serialization formats are plain text. Some are more readable than
others. In the author's opinion, the readability of serialization
formats ranges like following: YAML, Perl-based serialization, JSON,
Bencode, XML, Storable (which is a binary format).

=item Speed

A benchmark with results can be found here:
L<http://idisk.mac.com/christian.hansen/Public/perl/serialize.pl> (if
the URL is not available, then try the archive URL
L<http://web.archive.org/web/20060507091304/http://idisk.mac.com/christian.hansen/Public/perl/serialize.pl>).

Another comparison which is primarily aimed at caching may be found
here: L<http://cpan.robm.fastmail.fm/cache_perf.html>. Note that
caching is almost always used together with some serialization means.

=item Security

Some serializer modules allow the deserialization of code references,
which is possibly dangerous. But no module do this by default,
typically a switch has to be turned on.

Namely one serialization format has to use Perl's C<eval> or
C<Safe::reval> function for deserialization: L<Data::Dumper>.

L<Storable> may be configured to eval code references, which is
possibly a dangerous operation. This option is off by default.

=back

=head3 YAML

YAML as a format is neat: it's human readable, portable across
languages, unfortunately too complex.

Unfortunately the pure perl implementation L<YAML> has many many bugs.
It's really only suitable for simple stuff, but not for complex things
(e.g. data with self references, serialized code refs, unicode data
etc.).

L<YAML::Syck> is a C based parser for the YAML language. It's API
compatible with L<YAML> (has the same Load/Dump methods), but it's not
as configurable as L<YAML>. Performace seems to be quite good, also it
seems to be more standard-compliant as L<YAML>. For example, there's
no way to get L<YAML> dump/load utf-8 files, but in L<YAML::Syck> it's
at least configurable.

L<YAML::XS> (part of the YAML-LibYAML distribution) is also a C based
parser using libyaml instead of libsyck. This parser also support YAML
1.1. The 0.27 version has issues with latin1, but this is possibly
solved in the forthcoming 0.28 release.

L<YAML::Tiny> is a small parser/generator which only implements a
subset of YAML.

=head3 JSON/Javascript

JSON is a human readable format which is based on javascript syntax.
It's not so complex as YAML, but has the other advantages of YAML. A
pure perl implementation is L<JSON>. This module changed its main API
between 1.x and 2.x, so I cannot recommend it really for applications
which need stability.

L<JSON::Syck> is a C based parser for the JSON language.

L<JSON::XS> is another C based parser/generator for JSON. It seems to
be the only one which handles Unicode correctly. Like in L<JSON>, this
module also changed the main API functions between 1.x and 2.x.

L<JSON::PC> is now declared as non-maintained and buggy.

L<JSON::Any> is a wrapper which uses any installed available JSON
parser/generator. Using this module is a safe way to protect one from
the API changes in L<JSON> and L<JSON::XS>.

L<Data::JavaScript> serializes data structures from perl to
javascript, can handle circular structures, but output is quite
verbose.

L<Data::JavaScript::Anon> is also a serializer for perl data to
javascript syntax, cannot handle circular references, but the output
is more terse compared to Data::JavaScript.

=head3 XML

L<XML::Dumper> is a serialisation module for dumping Perl objects
from/to XML. As usually with XML, the output is very verbose and
probably slower than other modules. It's possible to include a DTD in
the generated XML document. There's no support for code references.

L<XML::Simple> can also be used for serializing/deserializing.

L<XML::Smart> --- the bad point about XML::Simple is, that one has to
carefully specify what goes into a hash or array or scalar, otherwise
the structure of the resulting data structure is somewhat undefined.
L<XML::Smart> tries to solve this problem by using an universal data
type which can be used either as hash or array or scalar. However, I
never tried this module in reality.

=head3 Bencode

The following modules can handle Bencode data: L<Convert::Bencode>,
L<Convert::Bencode_XS>.

=head3 Standard-less formats

L<Storable> is in the core since 5.7.3. It's fast (because implemented
in XS and using a binary format), but it's not human readable. The
file format is forward compatible and the module versions are backward
compatible, which means you can read all Storable-generated files with
a recent Storable version, but only a Storable file generated by an
old version can be read by all Storable versions. Storable has neat
features like customizable per-class hooks and the ability to
(de)serialize code references.

L<Data::Dumper> is in the core since 5.005. The output is
human-readable as it's perl code. Data::Dumper comes with an optional
XS part, but has also a pure-perl part. Deserializing is done through
eval() which is probably dangerous, Safe::reval should be preferred.
Deserializing is a little bit unhandy. Data::Dumper is also able to
serialize code references.

L<Data::Dump::Streamer> is maybe worthwhile to take a look on XXX.

L<Data::Denter> is a predecessor of YAML.

L<Data::Serializer> is a meta class for handling a couple of
serialization methods together with encryption, compression and
checksumming.

L<FreezeThaw> is ancient, pure-perl, and much slower than other
modules.

The benchmark by Christian Hansen also mentions the module
L<RPC::XML>.

L<PHP::Serialization> handles a serialization format which is popular
in the PHP world. But note that the current version 0.31 is not
recommended by the maintainer, due to some severe known bugs. Another
PHP serializer is L<PHP::Session::Serializer::PHP>.

L<Data::Pond> is dealing with the "Perl-based open notation for data".
It's somewhat similar as Data::Dumper, as the generated serialization
data is perl code and may be eval'ed, but it has also a
deserialization method to avoid the possibly dangerous eval operation.
Also, Data::Pond can only serialize a subset of Perl data, probably to
make the format language-independent.

L<Data::MessagePack> is a binary "packer" for perl data structures.
See L<http://cpanratings.perl.org/dist/Data-MessagePack> for reviews
on this serializer.

=head2 Validation

L<Data::FormValidator> is a rather old validation module which works
with CGI-like data, but may also be used for validation of generic
hashes.

L<Kwalify> implements the same-named schema language originally
appeared in the Ruby community.

L<Data::Rx> and L<Data::Schema> are new players in the data validation
business.

=head2 Hash tools

To get ordered hashes, use either L<Tie::IxHash> (which is old and
seems to be rock-stable), L<Tie::InsertOrderHash> (has problems with
older perls i.e. 5.005) or L<Tie::Hash::Indexed> (this is an XS
implementation of L<Tie::IxHash>, and, acoording to the documentation,
usually twice as fast as Tie::IxHash). And there are even more:
L<Tie::StoredOrderHash> (which has a comparison over the others),
L<Tie::LLHash>, L<Tie::Hash::ButMoreFun>.

For case insensitive hashes, use either L<Tie::CPHash> or
L<Hash::Case>.

Locking hash keys and/or values is done with the core module
L<Hash::Util>. See also L</Constants>.

=head2 Iterators

Check for L<Iterator> and L<Object::Realize::Later> (lazy
evaluation???). L<Object::Iterate> introduces an B<iterate> method to
loop conveniently over a list-like object.

=head2 Traverse

L<Data::Rmap> traverses complex data structures and makes it possible
to modify the elements in-place. Related modules are: L<Data::Walk>,
L<Data::Transformer>, L<Data::Traverse>.

=head2 Date and time modules

A complete implementation is offered by L<DateTime>, with a plethora
of plugins and additions (parsers, formatters, locale and time zone
support...). A list of DateTime-related modules may be found at
L<http://datetime.perl.org/?Modules>.

A classic one is L<Date::Calc>, a rather complete implementation of
date/time functions with a functional (somewhat non-perlish naming)
und object-oriented interfaces. It's written in C, so there's also a
pure perl replacement L<Date::Pcalc>.

The standard perl functions and modules: time, localtime, strftime and
mktime in L<POSIX>, L<Time::Local>.

Other efforts are: L<Time::Piece>, L<Date::Handler>, L<Date::Manip>
... A description of the many date and time modules may be found here
L<http://www.perl.com/pub/a/2003/03/13/datetime.html> (but the page is
unfortunately outdated --- L<DateTime> is not mentioned)

=head3 Faking time

L<fixedtime> changes functions time, gmtime and localtime to a
specified delta. It is a lexical pragma and therefore only works with
perl 5.10 and better.

L<Time::Fake> does the same thing, but is not lexically scoped and
therefore works also with older perls.

L<Time::Warp> seems to do similar things (to be evaluated).

=head2 Class support

=head3 Autogenerating accessors

L<Class::Struct>: in the perl core, has a strange syntax and I
remember other issues (no backward compatibility). Not very well
suited for OO, it's more for C-struct like things.

L<Class::Accessor>: stable. Has variants for fast access
L<Class::Accessor::Fast> and lvalue access L<Class::Accessor::Lvalue>
(but note that lvalue access has problems in perl and is still marked
as experimental).

L<Class::Accessor::Fast::XS> is compatible with
L<Class::Accessor::Fast>, but implemented in XS and somewhat faster.

L<accessors>: simple syntax, has also some variants. Test suite spits
a lot of warnings. A possible downside is that the internal hash
members are preceded with a dash. This makes serialized objects (e.g.
as YAML) not-so-nice to read and write.

L<Class::AccessorMaker>: ???

For an explanation what L<Object::Tiny> does, see
L<http://use.perl.org/~Alias/journal/34329>. This module only
implements read-only accessors, no mutators. The author claims that
L<Object::Tiny> is smaller and faster than L<Class::Accessor::Fast>.

L<Moose> does everything for OO, it seems, including generating
accessors.

L<Coat> is inspired by Moose and implements a subset of Moose's
features. Coat is self-contained.

L<Mouse> is another Moose clone missing some features but is
(according to the documentation) much faster than Moose.

=head2 Sorting

L<Sort::Key> is (according to the author) the fastest way to sort an
array by key.

L<Sort::Naturally> simultaneously sorts lexically and nummerically.

L<Sort::Version> and L<version> may be used to compare and sort
version numbers.

=head2 Weak references

Nowadays the preferred way is to use weaken in L<Scalar::Util>, a core
perl module. Former modules were L<WeakRef> ...

=head2 Constants

The core Perl pragma L<constant> is able to create sigil-less
constants. sigil-less is problematic because such constants are not
easily embedable in strings, and may not be used on the left-hand side
of a fat comma or as a hash key in a simple way. The perl interpreter
may do good optimizations with constants created using this pragma.

L<Readonly>, L<Readonly::XS>, and L<Const::Fast> are modules which
create constants (or read-only variables) which have sigils, meaning
that the disadvantages above disappear. The performance though is
worse, beginning with Readonly being the slowest and Const::Fast being
the fastest, but probably cannot be as fast as constants created by
the contant pragma.

L<Data::Lock> also uses Perl's internal feature to make a variable
immutable, therefore also being quite fast. L<Attribute::Constant>
adds some syntactic sugar to this module.

Another module exposing Perl's internal readonly flag is
L<Scalar::Readonly>. It works on scalars only, though.

The core module L<Hash::Util> has a set of functions to "lock" the
keys and/or values of a hash.

=head2 Cloning

L<Storable> has the function B<dclone()>. Most data types can be
cloned, including code references (if Deparse/Eval is turned on, but
with some restrictions regarding lexicals); but some data types
cannot, like regexps.

L<Clone> is a module dedicated for cloning.

L<Scalar::Util::Clone> is another clone module. Its documentation
claims that it is faster than Storable's dclone.

L<Data::Clone>, another XS-based clone module. It has a different
policy than Storable, in that not every data type is deeply cloned.
Especially blessed object are not cloned unless marked as clonable
(i.e. by defining a "clone" method). Reviews at CPAN ratings suggest
that it's faster than Storable.

=head2 Accessing

L<Data::Path> provides XPath-similar accessing methods to data
structures. A similar approach is L<Data::DPath>, which has a
comparison table between these both modules.

For just accessing a deep data structure L<Data::Diver> may also be
used. Using this module it is not necessary to differentiate between
subhashs and subarrays. Autovivification is avoided.

=head2 Comparing

A number of modules are available for comparing complex data
structures, for example L<Data::Compare>. This one lets you to ignore
some hash elements in the comparison, if needed. L<List::Compare> and
L<Array::Compare> may only do comparisons on lists/arrays. Using
L<Array::Compare> is not recommended anymore, as it uses the rather
heavy-weight L<Moose> module.

Is is also possible to do comparisons by serializing data structure
(e.g. using L<Data::Dumper> or L<Storable>) and do a string compare of
the serialized data. Make sure that the output is canonical, i.e. by
using Sortkeys(1) with L<Data::Dumper> or by setting
C<$Storable::canonical>.

See also L<below|/Generic test modules> for comparing within test
scripts (L<Test::Deep>).

To compare files, use the core module L<File::Compare>.

=head1 Database Interfaces

=head2 Object persistance

L<Storable> (see L<above|/Serialization>) and all other
(de)serialization modules. See also L<http://poop.sourceforge.net> for
a comprehensive list of perl object persistance modules.

=head2 Database Abstractions

L<Class::DBI> is popular. An offspring of this module is
L<DBIx::Class>. There are also L<Alzabo>, L<Rose::DB>. See also
L<http://poop.sourceforge.net/>, as database abstraction layers and
object persistence systems are mostly the same thing. Unfortunately
this page is somewhat outdated (from 2003) and it does not even
mention L<DBIx::Class>.

=head2 SQL Abstrations

=head3 Schema handling

L<SQL::Translator> seems to do everyhing: schema translation from
everything to everything, including diagrams and creating diffs. The
object model seems to be clean, separating parsers, producers, filters
and schema objects. Unfortunately it has also everything as PREREQ_PM,
including GD, GraphViz, Excel-related modules... Another downside is
that certain operations are quite slow, e.g. parsing a schema from an
SQL file or database. Supported database engines are MySQL, Oracle,
PostgreSQL, SQLite and many others.

L<DBIx::DBSchema> may me used for translating an existing database
schema (which will be read from a database) and create SQL statements
for another database engine. Especially there's no support for parsing
a schema from an SQL file. Supported database engines are MySQL,
PostgreSQL and SQLite, while Sybase and Oracle are partially supported
(from the docs).

L<MySQL::Diff> has a limited task of showing differences between two
mysql schemas (either from file or from a database) and create a
series of ALTER TABLE statements to bring one schema to the other.
Development to this module has stopped a lot of years ago, meaning
that newer MySQL versions (4.x, 5.x ...) are not supported without
manual tweaks.

=head2 File database systems

File database systems or dbm systems are simple database systems with
usually just a key-value relation and only one table per file.

A short overview of standard DBM systems which come with perl can be
looked at the L<AnyDBM_File> manpage. L<DB_File> has the most "+" in
the AnyDBM_File table, but has some problems: the database file format
changes across berkeley db versions, and there are reportedly many
problems with corrupted databases.

L<DBM::Deep> is a pure-perl implementation which can also handle deep
nested structures as values (other DBM implementations can only
handle scalars as values).

L<BerkeleyDB> interfaces berkeley db like L<DB_File>, but has a much
richer API (e.g. support for transactions).

L<BDB> allows asynchronous access to berkeley db.

L<CDB_File> is a "constant" database. This means that the database is
created only once, but reading is very fast. A pure perl variant is
L<CDB_Perl>.

To have L<MLDBM> sits on top of the other DBM implementations and
enables storing of deep nested structures. Unlike L<DBM::Deep>,
storing of object information is also possible.

L<MLDBM::Sync::SDBM_File> can be used to overcome the size limitations
of L<SDBM_File>.

L<DB_File::Lock> adds a locking layer to L<DB_File>.

L<MLDBM::Sync> adds a locking layer to L<MLDBM> files.

=head2 Search/fulltext engines

L<WAIT>, a fulltext engine. L<CPAN> has support for this module.

L<Senna>, an interface to the Senna fulltext search engine (from Pod:
"a fast, embeddable search engine that allows fulltext search
capabilities").

L<CLucene> and L<Lucene> are interfaces to the CLucene C++ search
engine. From looking at reports and ratings, it seems that C<Lucene>
is better supported.

L<Plucene>, a Perl port of the Lucene search engine.

L<Search::FreeText>: free text indexing module for medium-to-large
text corpuses

L<Text::English>: comes with the L<perlindex> script which lets users
search over all installed Perl documentation, including installed CPAN
modules.

More: L<Search::InvertedIndex>, L<Sphinx::Search>, L<SWISH>,
L<KinoSearch>, L<Search::Indexer> ...

=head2 Database utilities

For turning a database query result into a HTML table, one can use
L<DBIx::XHTML_Table> or L<HTML::Table::FromDatabase>.

=head1 Development Support

=head2 Test modules

=head3 Generic test modules

A comprehensive overview of test modules can be found at
L<http://qa.perl.org/test-modules.html> (An overview of the testing
modules available on CPAN).

Recommended Test module: L<Test::More>. Provides more functionality,
better extensibility and more diagnostics than the old L<Test> module.
Downside: Test::More is part of the core only since 5.7.3.

Worthwhile additions to Test::More: L<Test::Differences> to display a
diff-like output of the comparison of two strings or data structures.

L<Test::NoWarnings>: make sure that there are no warnings generated in
your test suite. This is the opposite of Test::Warn.

L<Test::Warn>: test the creation of warnings.

L<Test::Distribution>: test if a distribution is correct and complete
(POD checking, all modules compile, existance of standard files like
README). Simple to use.

L<Test::Deep>: compare deep structures with a lot of features. For
easier tests, is_deeply from Test::More should suffice. For large data
structures, using L<Data::Compare> may be faster than is_deeply.

L<Test::Without::Module>: emulates the non-existance of modules (e.g.
for optional features). Modules with similar functionality:
L<Devel::Hide>, L<Module::Mask>. L<Test::Without::Module> had some
problems with Tk, which are solved now. L<Devel::Hide> works well.
L<Module::Mask> not tested yet.

L<Test::LongString> helps in comparing long strings by only showing
relevant output. L<Test::Differences> may also used for this: it shows
the differences in complex objects in a diff style.

=head3 WWW and HTML related test modules

L<Test::HTTPStatus>: a very simple module for just checking the return
value (status code) of an URL.

L<Test::URI>: Check various parts of Uniform Resource Locators.

L<Test::HTML::Content>: Perl extension for testing HTML output (e.g.
expected links, content, xpath ...).

L<Test::HTML::Lint>: make lint tests to HTML.

L<Test::HTML::Tidy>: similar to Test::HTML::Lint, but uses the
external tidy library.

L<Test::WWW::Mechanize>: bring WWW::Mechanize and Test::More together

L<Test::WWW::Simple>: simple content tests.

L<CGI::Test>: ???

=head3 Other test modules

L<Test::XML>: Compare XML in perl tests.

=head2 Development, Perl Interna

=head3 Tracing

Simple tracing can be done with L<Devel::Trace>. Similar output is
generated by the "t" (trace) option of the normal perl debugger.
L<Devel::TraceCalls> allows programmable tracing by subs or packages.
The L<Devel::CallTrace> module is another one, which includes in its
Pod documentation a list of similar modules, so look there for a short
description for any of them.

L<Carp::Always> (formerly called C<Carp::Indeed>) turns every warn/die
into a stack trace including used parameters. Seems to be more
powerful than L<Acme::JavaTrace> and L<Devel::SimpleTrace>, which do
not dump parameters.

=head3 Profiling

L<Devel::NYTProf> is currently the state of the art profiler in the
Perl world. It allows subroutine- and statement-level profilers.
Reports are created as a series of HTML pages, but even other programs
(e.g. kcachegrind) may be used.

L<Devel::FastProf> and L<Devel::SmallProf>: profilers on line basis.
The first one has less impact on the execution time of the script
(according to the author, 3 to 5 times slower) and has less profiling
output, and the latter is much slower (about 50x), but has more
profiling output. At least Devel::FastProf turns out to be quite
useful.

L<Devel::DProf>: ancient, has problems with complicated stuff (e.g. Tk
scripts, saw segmentation faults and garbled profile files). Profiles
only on sub basis.

There are other profilers, which are untested: L<Devel::Profiler>,
some apache-specific profilers like L<Apache::Profiler>,
L<Devel::Profile>, L<Devel::DProfLB>, L<DashProfiler> ...

=head3 Memory tracing

L<Devel::Leak>: counts used scalars, so it's possible to determine
whether there's an increase of used SVs.

L<Devel::Leak::Object> (was recommended at cpanratings).

L<Devel::TrackObjects>: track the usage of objects, which can also be
used to find memory leaks.

L<Devel::FindRef> is designed to find memory leaks by creating a
detailed report of all yet active scalars with all references to it.

=head3 Compatibility support

L<Perl::MinimumVersion> determines the minimal required perl version
for given perl code. Unfortunately it's far from perfect, many modern
perl constructs are not yet recognized. See
L<http://rt.cpan.org/Public/Bug/Display.html?id=28916>.

The C<corelist> script, part of the L<Module::CoreList> module
distribution, knows when modules were part of the perl core, if ever.

=head2 Versioning control systems

L<VCS> (old, unmaintained), L<VCI> (new, at the moment actively
developed) and others. TBD: Look which one is the best nowadays.

L<Git> is included in the git core.

=head2 Regexp tools

L<Regexp::Assemble>: combine multiple regexpes into one. A faster but
more restricted module doing the same is L<Regexp::Trie>. Other
modules doing similar things are L<Regexp::Optimizer> and
L<Regex::PreSuf>.

=head1 Documentation

=head2 Pod

XXX podlators, Pod::Simple, various pod2html modules, App::Pod2CpanHtml XXX

=head1 File Handle Input/Output

=head2 IO

=head3 Reading/writing to a scalar

Since 5.8.0, this can be done with three-arg L<open|perlfunc/open> and
a scalar ref instead of a filename. For former perl versions, use
either L<IO::Scalar> or L<IO::String>. See
L<http://cpanratings.perl.org/dist/IO-String> for a rating which
compares IO::String and IO::Scalar (where the former seems to be
better than the latter).

=head1 File Name Systems Locking

=head2 File type detection

L<File::Type> uses exclusively an internal database. In its
documentation it explains its advantages over L<File::MimeInfo> and
L<File::MMagic>. Unfortunately the module seems to be rather
unmaintained since 2004.

L<MIME::Types>: the module is a file extension - mime type mapping.
The module is not looking at file's magic. It is supposed to work just
like the MIME type recognition of Apache.

L<LWP::MediaTypes> is part of libwww-perl. Like MIME::Types, it
deduces the mime type from the file name.

L<File::MimeInfo::Magic> needs the mime-info database from the
freedesktop project.

L<File::MMagic> uses either an small internal database (with about 100
file formats) or the host's magic file as found in F</etc/magic> or
elsewhere. Unfortunately the location of the magic file is different
from system to system, so it would be nice if there was an
E<quot>auto-detectE<quot> option.

An XS version of File::MMagic is available as L<File::MMagic::XS>. Its
documentation presents a benchmark where it is more than 20x faster
than the pure-perl version.

L<File::Type::WebImages> only determines common image file types ("web
image file types") using magic recognition. Its documentation lists
advantages over L<File::Type> and L<File::MMagic>.

L<File::LibMagic> is a perl interface to the libmagic library, which
means that you get the same results like the L<file(1)> command but
without the overhead of calling and parsing an external application.

=head2 File system

=head3 Copying files

L<File::Copy> is in the core. There's no support for recursive copying
or file attribute preservation.

L<File::NCopy> is able to make recursive copies and preserve file
attributes.

L<File::Copy::Recursive> is an alternative module for copying files
recursively.

=head3 Moving files

L<File::Copy> has a C<move> function which also can handle moving
across filesystem boundaries (which the perl function C<rename>
cannot).

L<File::PerlMove> provides a shell command C<pmv> to rename files
using perl expressions. Another implementation doing this is C<rename>
(originally by Larry Wall, and currently exists in numerous variants),
and sometimes part of operating system installs (e.g. available for
Debian or as a FreeBSD port).

=head3 Walking a file hierarchy

L<File::Find> is in the core. 

L<File::Find::Rule> is different XXX. Many plugins.

=head2 Free disk space

L<Filesys::DfPortable> is probably the best choice. It supports both
Windows and Unix systems.

L<Filesys::Df> and L<Filesys::Statvfs> seem to work on Unix systems.
Both need a C compiler. L<Filesys::Df> gives more portability, while
L<Filesys::Statvfs> can return more information about the file system.

L<Filesys::DiskSpace>: no usage of external commands, just using
syscalls through syscall.ph. Support seems to be stalled since many
years (there are test failures and old bug reports on rt.cpan.org).

L<Filesys::DiskFree> parses the output of the Unix tool C<df>. It does
not work with modern BSD systems, for instance. The module is very old
and seems to be unsupported.

=head1 Graphics

=head2 Graphic libraries

The classic one is L<GD>. It is not exactly easy to install, because
it has as libgd as a prerequisite, which is not always pre-installed.
To complicate matters, there are incompatible versions of GD and libgd
(1 and 2). Older versions of libgd1 had gif support, which was removed
for patent reasons. So many OS distributions still use the older
version to remain backwards compatibility. Maybe these things will
settle as the patent expired and newer libgd2 and GD2 versions come
with gif support again. libgd2 also has true color support, and there
is also true font support.

L<Image::Magick> (also known as PerlMagick) is, compared to GD, slow
but creates superior results. It's said that the API is not stable and
tends to change often. It's also not so easy to install because of the
dependency of the imagemagick program/library. An alternative to
ImageMagick is its offspring
L<http://www.graphicsmagick.org/|GraphicsMagick>, which also comes
with a Perl binding.

L<Imager> is a library which comes with the graphic library bundled in
the perl module distribution. So you only need the low-level libraries
like libpng and libjpeg installed on your system. The version number
of Imager is still 0.something, so expect that things do not work as
expected.

L<Image::Imlib2>: apparently an interface to the imlib2 library. Not
tested yet.

L<Prima> is originally a GUI toolkit, but it can handle image
operations also in a non-windowing environment.

Not a perl module, but still usable from a perl script/module is
netpbm (to be found on sourceforge). netpbm is a collection of filter
programs which can be piped together. For example: to resize a gif
image just use: giftoppm file.gif | pnmresize <size> | ppmtogif >
newfile.gif.

L<GraphViz> is a B<graph> library. Feed in a graph or tree and get a
graph as gif or postscript or Perl/Tk canvas output or ...

=head3 SVG

L<Image::LibRSVG> converts svg graphics into popular image formats.

L<SVG::GD> vs. L<GD::SVG>: use the GD API to create SVG graphivs.
Check the difference between both!

L<SVG> provides an API to create SVG graphics.

=head2 Image information

L<Image::Size> and L<Image::Info> may be used to get information about
an image file (like size, mime format etc.).

L<Image::EXIF> is an interface to EXIF information. Some EXIF
information can also be found in L<Image::Info>. There's also
L<Image::ExifTool>, which is (contrary to Image::EXIF) written in pure
perl.

L<GD> can be misused to determine if a file is an image at all by
loading the image into a GD::Image object (meaning at least that it's
an image format supported by GD), and has a getBounds method to get
the dimensions of the image. But this is not very efficient,
especially for large images.

L<Image::Magick> provides a "Ping" method which gets only basic
information (size and format) from the image without loading it
completely, so it's more efficient than GD.

=head2 Charts

L<GD::Graph> is a nice package to create plots, charts, pie diagrams
etc. via the L<GD> module.

L<GD::Graph3D> is like GD::Graph, but provides 3d-looking graph.

L<Chart::ThreeD::Pie> is another module to create 3d pie diagrams via
L<GD>.

L<Chart::Clicker> is based on the Cario graphics library and many
people think that its output is extremely beautiful.

=head1 Language Extensions

=head2 Exporting

The standard way for exporting symbols from a package to another is
the core module L<Exporter>. See L<Sub::Exporter/COMPARISONS>
explaining the strengths and weaknesses of L<Exporter>,
L<Exporter::Lite>, L<Exporter::Easy>, L<Exporter::Simple>,
L<Perl6::Export>, L<Perl6::Export::Attrs>, L<Exporter::Renaming>,
L<Class::Exporter>, L<Exporter::Tidy>.

=head2 Interfacing with C code

The "standard" way of interface to C code or a C library is the XS
language, part of core perl. See L<perlxs> and L<perlxstut> for more
information.

SWIG (L<http://www.swig.org/>) is a language-agnostic approach,
supporting also other programming languages like PHP, Python, Tcl and
Ruby.

Using L<FFI>, L<C::DynaLib> or L<P5NCI> C library functions may be
accessed without the need to write intermediate C code at all. Under
Windows, L<Win32::API> may be used to access the Windows API.

Last, with C<Inline::C> C code may be embedded in Perl code.

=head2 Interfacing with other languages

See the L<Inline> family of modules.

=head1 Mail and Usenet News

=head2 Sending and Receiving

L<Mail::Send> and L<Mail::Mailer> are used for composing and sending
simple messages. The modules are old and work somehow, but one has to
actually read the source rather than the documentation to learn all
the caveats. There's no support for constructing MIME mails. There are
multiple backends (sendmail, mail, smtp ...) built in.

L<Mail::Sendmail>: XXX check this one. Just for sending.

L<Net::SMTP>: A low-level module for accessing a SMTP server for
sending mails. No support for constructing messages.

L<Mail::Sender> a higher-level module around Net::SMTP ??? 

L<Mail::Box>: a comprehensive suite of mail manipulating modules. This
include: message construction, mbox/mail folder manipulation
(including access to POP3 mail accounts), sending mails. Support for
MIME mails.

L<Mail::Cclient> also gives access to various mailbox formats
(including IMAP mail accounts). The module relies on an additional C
library.

L<Mail::IMAPTalk> is an IMAP client interface.

=head2 Generating

The mentioned modules have mostly only support for generating plain
messages without MIME and attachments. For more complex emails with
attachments you need something like L<MIME::Lite>, L<MIME::Tools> or
L<Email::MIME>. There are claims that at least L<MIME::Lite> is buggy
and that L<Email::MIME> should be preferred.

=head1 Miscellaneous

=head2 Module installation

The classic module is L<CPAN>, which comes with core perl. Someday,
L<CPANPLUS> will be the successor of CPAN.pm some day (once it is
stable etc.). L<CPAN::Mini> is a module for creating a minimal mirror
of the CPAN repository.

=head2 Logic programming

A list can be found at
L<http://www.perlmonks.org/index.pl?node_id=424075>. A discussion at
L<http://www.mail-archive.com/sw-design@metaperl.com/msg00115.html>.

=head2 Building software

L<ExtUtils::MakeMaker> is the old-fashioned standard way of building
perl modules and applications. Unfortunately it depends on the
existance of a C<make> tool on the system, so there's now a pure-perl
solution in the beginnings: L<Module::Build>.

A C<make> replacement as a perl module: L<Make>, together with a
command line tool C<pmake>.

L<Commands::Guarded> is an interesting module for guarded execution of
commands (better description!).

L<PANT> is meant as an C<ant> replacement to help to automate a build
environment. It is usually used as a meta script which calls external
C<make> commands and has some built-ins like NewerFile, CopyFile etc.

L<Cons> is a make replacement. Cons files are written in pure perl.

=head2 Parsers

See
L<http://sourceforge.net/docman/display_doc.php?docid=27420&group_id=133629>
about a comparison between L<Parse::RecDescent>, L<Parse::Yapp>, and
Perl-byacc.

=head2 CRC

L<String::CRC32>: fast, written in C.

L<Digest::Crc32>: very slow, written in pure perl.

There are also L<Digest::CRC> and L<String::CRC>.

=head2 Password generators

There are L<String::Random> and L<String::MkPasswd>.

=head2 Logging

A list of available logging modules can be found at:
L<http://search.cpan.org/dist/Log-Dispatch/lib/Log/Dispatch.pm#RELATED_MODULES>.

=head2 Logfile parsing

David Newcum lists in L<http://cpanratings.perl.org/user/interiot> a
number of modules which do logfile parsing: L<Logfile::Access>,
L<http://www.oreilly.com/catalog/perlwsmng/chapter/ch08.html>,
L<Regexp::Log>, L<HTTPD::Log::Filter>, AWStats' awstats.pl,
L<http://www.fourmilab.ch/fourmilog/archives/2005-03/000500.html>,
and, as the worst example, L<Apache::ParseLog>.

=head2 System administration

L<Sysadm::Install>: a box full of tools typical for automated
installation tasks. Looks very nice.

L<Commands::Guarded>: this is more a paradigma the a toolbox: every
action has a should-condition and an action. So it's possible to
restart a script after a previous failure and determining errors is
not done by checking error coded, but by checking the
should-condition.

=head2 Geo modules

=head3 Geocoding

L<Geo::Coder::Google> is an interface to the Google Geocoding API. It
requires an API key, which has restrictions on its usage. Results
seems to be good, at least for the Germany area.

L<Geo::Coder::GoogleMaps> is a similar module which just uses a
different interface to the API (JSON instead of XML). The results
should be of the same quality like L<Geo::Coder::Google>.

L<Geo::Coder::Yahoo> is an interface to the Yahoo Geocoding API. It
also requires an API key, but there does not seem to be any
restrictions on usage, unlike the Google API. Results are not that
good, at least for the Germany area, and there seem to be problems
with umlauts, so avoid them.

L<Geo::Coder::Bing> is an interface to the geocoding API from
L<http://www.bing.com>. It does not require any API key. Results seem
to be good, at least for the Germany area.

L<Geo::Coder::US> is an interface to the free US geo data.

L<Geo::Coder::Mapquest> is an interface to the beta Mapquest Geocoding
Web Service. The service requires an API key. According to the manpage
of version 0.01, the results are often not good for the US area, and
there are no results for addresses outside the US.

L<Geo::Coder::Cloudmade> is an interface to the Cloudmade API, which
is using data from the OpenStreetMap project. An API key is required.

L<Geo::Coder::OSM> is another interface an API using OpenStreetMap
data. No API key is required.

=head3 Other

L<Geo::Google> is an interface to Google maps.

=head2 Terminal input

Use L<Term::Readkey> for one-key-at-a-time input (visible or
invisible). Useful also for invisible password input.

L<Term::ReadLine>: a perl module similar to readline. Enabled line
editing and history handling. Comes in two flavours:
L<Term::ReadLine::Perl> and L<Term::ReadLine::Gnu> (XXX what's the
difference between those two?)

L<IO::Prompt>: from the SYNOPSIS it's a nice module for prompting a
string and getting an answer. Has a lot of useful options (defaults,
input filters ...). But it does not seem to run under Windows.

=head3 Progress indicators

L<Term::ProgressBar> draws a progress bar to the terminal.
L<Term::ProgressBar::Quiet> does the same, but checks first if the
output device is a terminal at all (useful for scripts which may run
as cron jobs, for instance).

L<Time::Progress> may also draw a progress bar and has a rich set of
formatting parameters (e.g. showing the ETA etc.).

L<Tk::ProgressBar> for a graphical progress bar. L<IWL::ProgressBar>
for a web progress bar based on the L<IWL> library.

L<Term::Spinner> draws a classic spinner (a rotating bar).
L<Term::Twiddler> does the same thing, but seems to allow for more
configuration. For multiple spinners, one can use
L<Term::MultiSpinner>.

More in the same league: L<Term::Activity>, a huge framework
L<ProgressMonitor>, L<Acme::Spinner>, L<Acme::Spinners> (with a set of
different spinners).

=head2 AI

A long link list for AI and NLP stuff can be found here:
L<http://perlmonks.org/?node_id=399498>.

=head2 Bio

A long link list for Bioinformatics stuff can be found here:
L<http://perlmonks.org/?node_id=399498>.

=head2 Job Queues

Distributed systems are L<TheSchwartz> and L<Gearman>.

=head1 Networking Devices IPC

=head2 Network Utilities

=head3 IP address matching

L<Net::IP::Match::Regexp> is a module to match IP addresses against
ranges. This module contains also a list of similar modules with a
comparison (L<Net::IP::Match>, L<Net::IP::Match::XS>,
L<Net::IP::Resolver>).

Another module for parsing, manipulating and looking up IP network
blocks is L<Net::Netmask>.

=head2 SSH

L<Net::SSH> is a simple wrapper around the L<ssh(1)> command. Cannot
send proper command line arguments to remote. Does not support
arbitrary ssh options. It seems that there's no active development
anymore.

L<Net::SSH::Perl> is a ssh implementation written in perl and does not
need an ssh installed.

L<Net::SSH::Expect> also uses the system's ssh like L<Net::SSH>, but
adds also the capabilities of L<Expect> into it.

L<Net::OpenSSH> is a new player. The Pod documentation of this module
has a comparison against the other available ssh implementations.

=head1 Option Parameter Config Processing

=head2 Config/Ini files

L<YAML> is both good for (de)serialization and config files. API is
very simple to use. Note the overwhelming bug list on
L<http://rt.cpan.org>, but for normal configuration files it should
work OK.

L<savevars>: my own pragma module for conveniently storing and
retrieving a configuration.

L<Config::IniFiles>: most people recommend this module for Windows-ini
styled configuration files. More modules in this game:
L<Config::Tiny>, L<Config::IniHash>, L<Config::Mini>, and
L<Config::INI::Simple>. L<Config::Any::INI> can read ini files, but
not write them.

L<XML::Simple>: out-of-the-box serialization is not possible without
fiddling with a lot of options

L<Config::Model>: a configuration framework for parsing and analyzing
all kinds of configuration file. Includes generating a curses screen
to let the user input the options. Have many features like automatic
comment creation, help screens, different levels
(novice/intermediate/...).

=head1 String Language Text Processing

=head2 XML related modules

Best reference is probably L<http://perl-xml.sourceforge.net/>,
containing the Perl XML FAQ.

Some benchmarks can be found at
L<http://www.xmltwig.com/article/simple_benchmark/>.

=head3 Parser

L<XML::Parser>: the mother of all XML processing modules. It works,
though on a very low level (if you compare with other fields Perl is
strong). I suspect it's just the fact that a DOM/XML tree does not
easily fit into the hash/array/scalar world of Perl.

L<XML::Parser::EasyTree>: like C<XML::Parser> with Tree style, but the
generated tree is more readable.

L<XML::Parser::Lite>: a pure perl implementing a complete XML parser,
without any other dependencies.

L<XML::Tiny> is also a pure perl parser implementing parsing of a
rather deliberately chosen subset of XML. Therefore, especially if you
don't have control over the XML source, it is not recommended to use
it in real production (and if you have control over the source, most
times it is preferable to use another data serialization format like
YAML, JSON, Storable or so).

L<XML::SAX::PurePerl>: a pure perl XML parser with SAX2 interface

=head3 Parser/Generators

L<XML::LibXML>, an interface to the libxml2 library. The library comes
with a number of methods to access an XML document: the SAX parser,
which feels rather low-level, but is OK; also accessing through DOM
with XPath support.

L<XML::Simple>, a high-level interface. For serious work there's a
lot of options to fiddle with, but the documentation is extensive and
marks the options which are important and which are not.

L<XML::Mini>, an implementation of a DOM-like API. Module seems to be
buggy and unmaintained.

L<XML::Twig> is feature-rich, has support for in-memory and chunked
parsing, xpath operations, good documentation, a section on
competitors. The author admits that it is slower than XML::LibXML, but
uses less memory. Never used it, though.

L<XML::Bare> is, according to the docs, a fast XML parser which
implements only a subset of XML. Its doc has a comparison table about
the parsing performance of the existing XML parsers.

=head3 Normalization/Canonicalization

There are L<XML::Normalize::LibXML> and L<XML::CanonicalizeXML>
available. The latter implements W3C recommendations.

=head3 Feeds

Parsing and generating RSS: L<XML::RSS> generally works fine, but may
be quite slow on parsing some types of RSS feeds (taking ~5 seconds on
normal computers). L<XML::RSS::Parser> is more light-weight than
L<XML::RSS> and provides only parsing capabilities. It seems to be
significantly faster than L<XML::RSS> (probably dependent on the used
XML::SAX driver). L<XML::RSS::Tools> provides client capabilities and
expects an XSLT stylesheet which does the converstion of rss content.
L<XML::RSS::Feed> runs on top of L<XML::RSS> and provides caching
abilities.

Parsing and generating Atom: L<XML::Atom>...

=head3 Utilities

L<Tk::XMLViewer> displays an XML tree in a Tk window.

=head2 Templating systems

A comparison of web centered templating systems can be found at
L<http://perl.apache.org/docs/tutorials/tmpl/comparison/comparison.html>.
And here's another one:
L<http://www.perl.com/lpt/a/2001/08/21/templating.html>. Here's a
benchmark:
L<http://search.cpan.org/perldoc?bench_various_templaters.pl> (part of
L<http://search.cpan.org/dist/Template-Alloy/>. The examples directory
of L<HTML::Template::Compiled> also includes a benchmark script, but
without numbers in it.

=head3 Standalone templating systems

There are too many around there. Just to name some:

L<Template> (Template-Toolkit), a very popular and feature-rich
system. Good documentation, good support.

L<HTML::Template>, another popular system. Not so feature-rich like
Template-Toolkit. Focus on HTML.

L<HTML::Template::Compiled> uses the same templating language as
L<HTML::Template>, but internally compiles the template to perl code,
so it's faster in persistent systems (about 2-4x).

L<Text::ScriptTemplate>, a asp/jsp-like system to embed perl in a
template. Small and useful.

L<Template::Alloy> is, according to its documentation, a fast
templating system which can emulate some of the other popular systems,
including Template-Toolkit and HTML::Template.

L<Text::Xslate> is a scalable template engine for Perl5, and according
to its documentation, very fast (claiming to be 100x faster than TT2).

=head3 Meta templating systems

L<Any::Template> is a wrapper around the major templating systems
using the same API for all.

=head3 Apache

L<Apache::ASP> a framework with a jsp/asp-like templating system (XXX
check), to be used in conjuction with L<mod_perl>.

EmbPerl (L<HTML::Embperl>). More than just templating XXX?

Mason (L<HTML::Mason>). More than just templating XXX?

L<Apache::SimpleTemplate>, a mod_perl handler for using jsp/asp-like
templates. It seems to be rather lightweight in comparison to
Apache::ASP.

=head2 PDF handling

L<PDF::Create> works. Best to use version 0.06 from sourceforge
(project perl-pdf).

L<PDF::API2> is big and complete. But its seems to be slower than
PDF::Create, at least for my needs.

In L<CAM::PDF>'s SEE ALSO Pod section there's a comparison between a
couple of PDF-related modules.

There are some templating solutions (PDF::Reuse, PDF::Template). And
there's also (non-perl) pdflatex!

=head2 Approximate matching

L<String::Approx> uses the Levenshtein edit distance. The core is
implemented in C. Older versions of C<String::Approx> (version 2) also
have a slower perl implementation.

L<String::Similarity> returns a similarity index of two strings.

L<String::Trigram> finds similar strings by trigram (or 1, 2, 4,
etc.-gram) method.

L<Text::LevenshteinXS> calculates the Levenshtein edit distance (which
is used in String::Approx, for example) between two strings.
L<Text::Levenshtein> is a pure perl implementation.

Just for completeness: there's also the command line agrep, see
L<http://en.wikipedia.org/wiki/Agrep>.

=head2 Stripping accents

L<Text::Unidecode>: highly recommended, handles all Unicode
characters. There are also L<Text::Unaccent>,
L<Text::StripAccents> and L<Text::Undiacritic>.

=head1 User Interfaces

=head2 GUI toolkits

L<Tk> is mature and runs on X11, Windows and MacOSX under XDarwin.
Further alternatives are: L<Wx>, L<Gtk2>, L<Qt>, L<Prima>,
L<Win32::GUI> etc. (A GUI toolkit comparison can be found at
L<http://www.perlmonks.org/?node_id=108708>). L<X11::Protocol> for a
low-level interface to the X11 windowing system --- good in conjuction
with a higher level GUI toolkit like Tk.

L<Qt> is only for the library version 2.0, while the current version
is at 4.0.

L<IWL> is a widget library for the web.

=head2 Console based GUI toolkits

Low level: L<Curses>.

Higher level: L<CDK>, L<Curses::UI>, L<Curses::Widgets>.

Here's a comparison between L<Curses::UI> and L<Curses::Application>
(sorry, German only):
L<http://groups.google.com/group/de.comp.lang.perl.misc/browse_thread/thread/6e8da30ef98fb386#0df9b3146ac61a05>

=head2 GUI builder

For L<Tk>: L<ZooZ> is actively developed. It is not exactly of the
type "drag'n'drop", but seems to be useful. L<specPerl> (not on CPAN)
is old, but probably useful. L<guido> (on Sourceforge) hast no active
development anymore, and is not in a useful state.

=head2 Tk widgets

=head3 Date widgets

L<Tk::Date>: a highly configurable text only entry widgets.

L<Tk::DateEntry>: a BrowseEntry-like widgets which pops up a calendar

L<Tk::DatePick>: a date widget which is only selectable using
back/forward buttons (one for each date, month, year).

L<Tk::MiniCalendar>: the calendar view looks like Tk::DateEntry, but
the widget is not linked to a BrowseEntry widget.

=head3 (Multicolumn) Listboxes, Tables

L<Tk::Listbox>: a core Tk widget. Cannot use multiple columns, other
than defining a fixed font a fake multiple columns. Since Tk804 it's
possible to define a limited set of per-entry configuration
(foreground color, others?).

L<Tk::HList>: a core Perl/Tk widget, which has headers (through
L<Tk::ResizeButton> also clickable and useable to resize columns),
multiple columns, different styles for every cell, the possibility to
use widgets or images in cells.

L<Tk::MListbox>: XXX, are there others?

L<Tk::Table>: a pure Perl/Tk table implemenentation. Rather complete,
but slow on large tables, as each cell is represented by a widget.

L<Tk::TableMatrix>: an XS extension to create tables. Complete and
much faster than Tk::Table.

=head3 Error handling

If the standard Tk module L<Tk::ErrorDialog> is loaded, then fatal
errors (only) will go into a dialog instead to STDERR.

L<Tk::Stderr> redirects B<all> STDERR output to a toplevel window. The
window may be iconified and will auto-deiconify if there's new STDERR
output.

L<Tk::Carp> works similar to C<CGI::Carp> by redirecting warn and die
calls, in this case to Tk dialogs. Note that this module does not
catch STDERR (unlike Tk::Stderr).

=head1 World Wide Web

=head2 Client

L<LWP>, L<LWP::UserAgent>, L<LWP::Simple> (higher level, has also HTTP
methods, but no methods like POP3, SMTP).
L<LWP>: top-level module, use this for CPAN updates
L<LWP::UserAgent>: use this for doing requests in the WWW space
L<LWP::Simple>: use this if you want an very simple interface
L<IO::All>: for an even simpler interface

L<WWW::Curl> is a HTTP client built on top of libcurl. According to
the manpage LWP is still preferred to use, unless one needs more speed
or parallelism.

There are other light-weight HTTP implementations, which are not
complete as LWP, but smaller in size and module number and probably
also faster. These are L<HTTP::Lite> and L<HTTP::Client> (where the
latter needs C<HTTP::Lite> as a dependency and the version 1.51 seems
to be broken).

There is a number of extensions to L<LWP::UserAgent>, like
L<LWP::UserAgent::WithCache> and L<LWP::UserAgent::Cache::Memcached>
(with caching support), L<LWPx::ParanoidAgent> (an user agent with
additional restricions, e.g. refusing connecting to internal
addresses), L<LWP::ParallelUA> (parallel fetching),
L<LWP::UserAgent::Determined> (an user agent which retries a few times
in case of transient errors) ...

libnet (L<Net::FTP>) etc. (more low-level, has FTP, but no HTTP (?),
POP3, SMTP etc.).

L<WWW::Mechanize>: a class on top of L<LWP::UserAgent>, can be used to
mechanize WWW requests. L<WWW::Automate> is similar, but outdated and
not supported anymore. L<HTTP::Recorder> is a supporting tool for
WWW::Mechanize: it acts like a proxy and spits out WWW::Mechanize
scripts. Useful for automated test systems, if it'd be supported (but
look at http://rt.cpan.org and the overwhelming bug list).

L<WWW::Mechanize::Shell> is a shell for driving WWW::Mechanize and
creating scripts for this module.

=head2 Server

L<HTTP::Proxy> to create a HTTP proxy.

L<HTTP::Daemon> for a pure perl HTTP daemon. Other pure perl http
daemons: tinyhttpd, httpi (links missing). For perl support in the
Apache server see L<mod_perl> and the CGI support in Apache.

=head2 Web Frameworks

There's a wiki page some of the existing frameworks for web
development:
L<http://www.perlfoundation.org/perl5/index.cgi?web_frameworks>

L<Catalyst> --- The Elegant MVC Web Application Framework 

L<Maypole>. A MVC system for Apache or cgi-bin.

See also L<HTML::Mason> and maybe L<Apache::ASP>, which are more than just
templating systems (is this true XXX?).

L<Jifty>.

L<Dancer> - lightweight yet powerful web application framework.

=head3 CGI based frameworks

L<CGI::Application>

=head3 CMS

L<Contentment> --- a perl based Web CMS (check it XXX).

=head2 Wiki

L<CGI::Wiki>: nice, modular, not out-of-the-box, but relatively easily
configurable.

L<Kwiki>: popular.

L<http://www.twiki.org> (not a CPAN module). Also popular,
feature-rich, slow.

=head2 URI handling

L<URI> has full-flavored support for different URI schemes. One major
problem: URI only supports the "&" query param separator and not the
";" separator. The latter is recommended by RFC XXX; also this means
L<URI> cannot parse query parameter string generated by L<CGI>
correctly.

L<CGI> has limited support for URI handling through the url() and
query_string() functions and the new() constructor.

=head2 Apache/mod_perl support

=head3 Compression

A number of modules solve the problem "automatically (gzip) compress
outgoing data if the client supports it". Probably the most
comprehensive mod_perl handler (just by looking at the documentation
size) is L<Apache::Dynagzip>. More light-weight solutions are
L<Apache::Compress> and L<Apache::GzipChain> (the latter in
conjunction with the L<Apache::OutputChain>). All three can handle
static files. L<Apache::Dynagzip> has recipes how to work with L<CGI>
or L<Apache::Registry> scripts).

L<CGI::Compress::Gzip> is only suitable for CGI scripts. It
automatically turns the standard output into a gzip-compressed stream,
if suitable.

=cut
