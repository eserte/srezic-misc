=head1 Test modules

=head2 Generic test modules

A comprehensive overview of test modules can be found at
L<http://qa.perl.org/test-modules.html> (An overview of the testing
modules available on CPAN).

Recommended Test module: L<Test::More>. Provides more functionality,
better extensibility and more diagnostics than the old L<Test> module.
Downside: Test::More is part of the core only since 5.7.3.

Worthwhile additions to Test::More: L<Test::Differences> to display a
diff-like output of the comparison of two strings or data structures.

L<Test::NoWarnings>: make sure that there are no warnings generated in
your test suite. This is the opposite of Test::Warn.

L<Test::Warn>: test the creation of warnings.

L<Test::Distribution>: test if a distribution is correct and complete
(POD checking, all modules compile, existance of standard files like
README). Simple to use.

L<Test::Deep>: compare deep structures with a lot of features. For
easier tests, is_deeply from Test::More should suffice.

L<Test::Without::Module>: emulate the non-existance of modules (e.g. for
optional features).

=head2 WWW and HTML related test modules

L<Test::HTTPStatus>: a very simple module for just checking the return
value (status code) of an URL.

L<Test::URI>: Check various parts of Uniform Resource Locators.

L<Test::HTML::Content>: Perl extension for testing HTML output (e.g.
expected links, content, xpath ...).

L<Test::HTML::Lint>: make lint tests to HTML.

L<Test::HTML::Tidy>: similar to Test::HTML::Lint, but uses the
external tidy library.

L<Test::WWW::Mechanize>: bring WWW::Mechanize and Test::More together

L<Test::WWW::Simple>: simple content tests.

L<CGI::Test>: ???

=head2 Other test modules

L<Test::XML>: Compare XML in perl tests.

=head1 List/Array modules

Handy utility functions can be found in the core module (since 5.7.3)
L<List::Util>. Functions missing in this module are gathered in the
CPAN module L<List::MoreUtils>. This module also obsoletes the CPAN
modules L<List::MoreUtil> and L<List::Utils>.

=head1 GUI toolkits

L<Tk> is mature and runs on X11, Windows and MacOSX under XDarwin.
Further alternatives are: L<Wx>, L<Gtk2>, L<Qt>, L<Prima>,
L<Win32::GUI> etc. (A GUI toolkit comparison can be found at
L<http://www.perlmonks.org/?node_id=108708>). L<X11::Protocol> for a
low-level interface to the X11 windowing system --- good in conjuction
with a higher level GUI toolkit like Tk.

=head1 Console based GUI toolkits

Low level: L<Curses>.

Higher level: L<CDK>, L<Curses::UI>.

=head1 GUI builder

For L<Tk>: L<ZooZ> is actively developed. It is not exactly of the
type "drag'n'drop", but seems to be useful. L<specPerl> (not on CPAN)
is old, but probably useful. L<guido> (on Sourceforge) hast no active
development anymore, and is not in a useful state.

=head1 Tk widgets

=head2 Date widgets

L<Tk::Date>: a highly configurable text only entry widgets.

L<Tk::DateEntry>: a BrowseEntry-like widgets which pops up a calendar

L<Tk::DatePick>: not yet tested

=head2 (Multicolumn) Listboxes, Tables

L<Tk::Listbox>: a core Tk widget. Cannot use multiple columns, other
than defining a fixed font a fake multiple columns. Since Tk804 it's
possible to define a limited set of per-entry configuration
(foreground color, others?).

L<Tk::HList>: a core Perl/Tk widget, which has headers (through
L<Tk::ResizeButton> also clickable and useable to resize columns),
multiple columns, different styles for every cell, the possibility to
use widgets or images in cells.

L<Tk::MListbox>: XXX, are there others?

L<Tk::Table>: a pure Perl/Tk table implemenentation. Rather complete,
but slow on large tables, as each cell is represented by a widget.

L<Tk::TableMatrix>: an XS extension to create tables. Complete and
much faster than Tk::Table.

=head1 Serialization

L<YAML> is neat: it's human readable, portable across languages, but
unfortunately the Perl implementation is buggy so that's unusable
(other than for configuration files).

L<Storable> is in the core since 5.7.3. It's fast (because implemented
in XS and using a binary format), but it's not human readable. The
file format is forward compatible and the module versions are backward
compatible, which means you can read all Storable-generated files with
a recent Storable version, but only a Storable file generated by an
old version can be read by all Storable versions. Storable has neat
features like customizable per-class hooks and the ability to
(de)serialize code references.

L<Data::Dumper> is in the core since 5.005. The output is
human-readable as it's perl code. Data::Dumper comes with an optional
XS part, but has also a pure-perl part. Deserializing is done through
eval() which is probably dangerous, Safe::reval should be preferred.
Deserializing is a little bit unhandy. Data::Dumper is also able to
serialize code references.

L<Data::Dump::Streamer> is maybe worthwhile to take a look on XXX.

L<Data::Denter> is a predecessor of YAML.

L<XML::Dumper> is a serialisation module for dumping Perl objects
from/to XML. As usually with XML, the output is very verbose and
probably slower than other modules. It's possible to include a DTD in
the generated XML document. There's no support for code references.

L<Data::Serializer> is a meta class for handling a couple of
serialization methods together with encryption, compression and
checksumming.

L<FreezeThaw> is ancient, pure-perl, and much slower than other
modules.

=head1 Config/Ini files

L<YAML> is both good for (de)serialization and config files. API is
very simple to use. Note the overwhelming bug list on
L<http://rt.cpan.org>, but for normal configuration files it should
work OK.

L<savevars>: my own pragma module for conveniently storing and
retrieving a configuration.

L<Config::IniFiles>: most people recommend this module for Windows-ini
styled configuration files.

L<XML::Simple>: out-of-the-box serialization is not possible without
fiddling with a lot of options

=head2 Serialization to other languages

L<Data::JavaScript> from perl to javascript, can handle circular
structures, but output is quite verbose

L<Data::JavaScript::Anon> from perl to javascript, cannot handle
circular references, but the output is terse compared to
Data::JavaScript

L<YAML>, see above.

L<XML::Simple>, see above and below.

=head1 XML related modules

Best reference is probably L<http://perl-xml.sourceforge.net/>,
containing the Perl XML FAQ.

=head2 Parser

L<XML::Parser>: the mother of all XML processing modules. It works,
though on a very low level (if you compare with other fields Perl is
strong). I suspect it's just the fact that a DOM/XML tree does not
easily fit into the hash/array/scalar world of Perl.

L<XML::Parser::EasyTree>: like C<XML::Parser> with Tree style, but the
generated tree is more readable.

=head2 Parser/Generators

L<XML::LibXML>, an interface to the libxml2 library. Used the SAX
parser --- low-level work, but worked OK.

L<XML::Simple>, a high-level interface. For serious work there's a
lot of options to fiddle with, but the documentation is extensive and
marks the options which are important and which are not.

=head2 Utilities

L<Tk::XMLViewer> displays an XML tree in a Tk window.

=head1 Graphic libraries

The classic one is L<GD>. It is not exactly easy to install, because
it has as libgd as a prerequisite, which is not always pre-installed.
To complicate matters, there are incompatible versions of GD and libgd
(1 and 2). Older versions of libgd1 had gif support, which was removed
for patent reasons. So many OS distributions still use the older
version to remain backwards compatibility. Maybe these things will
settle as the patent expired and newer libgd2 and GD2 versions come
with gif support again. libgd2 also has true color support, and there
is also true font support.

L<Image::Magick> (also known as PerlMagick) is, compared to GD, slow
but creates superior results. It's also not so easy to install because
of the dependency of the imagemagick program/library. An alternative
is L<Graphics::Magick> (more stable, but not yet --- 2005-02-14 --- on
CPAN).

L<Imager> is a library which comes with the graphic library bundled in
the perl module distribution. So you only need the low-level libraries
like libpng and libjpeg installed on your system. The version number
of Imager is still 0.something, so expect that things do not work as
expected.

Not a perl module, but still usable from a perl script/module is
netpbm (to be found on sourceforge). netpbm is a collection of filter
programs which can be piped together. For example: to resize a gif
image just use: giftoppm file.gif | pnmresize <size> | ppmtogif >
newfile.gif.

L<GraphViz> is a B<graph> library. Feed in a graph or tree and get a
graph as gif or postscript or Perl/Tk canvas output or ...

L<Image::LibRSVG> converts svg graphics into popular image formats.

=head1 Graphic utitilies

L<Image::Size> and L<Image::Info> may be used to get information about
an image file (like size, mime format etc.). I had some exotic jpegs
which did not work with Image::Info, but worked with Image::Size.

=head1 Charts

L<GD::Graph> is a nice package to create plots, charts, pie diagrams
etc. via the L<GD> module.

L<Chart::ThreeD::Pie> is another module to create pie diagrams via
L<GD>.

=head1 Search/fulltext engines

L<WAIT>, a fulltext engine. L<CPAN> has support for this module.

=head1 Object persistance

L<Storable> (see above) and all other (de)serialization modules. See
also L<http://poop.sourceforge.net> for a comprehensive list of perl
object persistance modules.

=head1 Database Abstractions

L<Class::DBI> is popular. There are also L<Alzabo>, L<Rose::DB>. See
also L<http://poop.sourceforge.net/>, as database abstraction layers
and object persistence systems are mostly the same thing.

=head1 File database systems

File database systems or dbm systems are simple database systems with
usually just a key-value relation and only one table per file.

A short overview of standard DBM systems which come with perl can be
looked at the L<AnyDBM_File> manpage. L<DB_File> has the most "+" in
the AnyDBM_File table, but has some problems: the database file format
changes across berkeley db versions, and there are reportedly many
problems with corrupted databases.

L<DBM::Deep> is a pure-perl implementation which can also handle deep
nested structures as values (other DBM implementations can only
handle scalars as values).

L<CDB_File> is a "constant" database. This means that generating the
database is costly, but reading is very fast.

To have L<MLDBM> sits on top of the other DBM implementations and
enables storing of deep nested structures. Unlike L<DBM::Deep>,
storing of object information is also possible.

L<MLDBM::Sync::SDBM_File> can be used to overcome the size limitations
of L<SDBM_File>.

L<DB_File::Lock> adds a locking layer to L<DB_File>.

L<MLDBM::Sync> adds a locking layer to L<MLDBM> files.

=head1 Development, Perl Interna

=head2 Weak references

Nowadays the preferred way is to use weaken in L<Scalar::Util>, a core
perl module. Former modules were L<WeakRef> ...

=head1 Wiki

L<CGI::Wiki>: nice, modular, not out-of-the-box, but relatively easily
configurable.

L<Kwiki>: popular.

L<http://www.twiki.org> (not a CPAN module). Also popular,
feature-rich, slow.

=head1 Network

=head2 Client stuff

L<LWP>, L<LWP::UserAgent>, L<LWP::Simple> (higher level, has also HTTP
methods, but no methods like POP3, SMTP).
L<LWP>: top-level module, use this for CPAN updates
L<LWP::UserAgent>: use this for doing requests in the WWW space
L<LWP::Simple>: use this if you want an very simple interface
L<IO::All>: for an even simpler interface

libnet (L<Net::FTP>) etc. (more low-level, has FTP, but no HTTP (?),
POP3, SMTP etc.).

L<WWW::Mechanize>: a class on top of L<LWP::UserAgent>, can be used to
mechanize WWW requests. L<WWW::Automate> is similar, but outdated and
not supported anymore. L<HTTP::Recorder> is a supporting tool for
WWW::Mechanize: it acts like a proxy and spits out WWW::Mechanize
scripts. Useful for automated test systems, if it'd be supported (but
look at http://rt.cpan.org and the overwhelming bug list).

L<WWW::Mechanize::Shell> is a shell for driving WWW::Mechanize and
creating scripts for this module.

=head2 Server stuff

L<HTTP::Proxy> to create a HTTP proxy.

L<HTTP::Daemon> for a pure perl HTTP daemon. Other pure perl http
daemons: tinyhttpd, httpi (links missing). For perl support in the
Apache server see L<mod_perl> and the CGI support in Apache.

=head2 Mail

L<Mail::Send> and L<Mail::Mailer> are used for composing and sending
simple messages. The modules are old and work somehow, but one has to
actually read the source rather than the documentation to learn all
the caveats. There's no support for constructing MIME mails. There are
multiple backends (sendmail, mail, smtp ...) built in.

L<Mail::Sendmail>: XXX check this one. Just for sending.

L<Net::SMTP>: A low-level module for accessing a SMTP server for
sending mails. No support for constructing messages.

L<Mail::Sender> a higher-level module around Net::SMTP ??? 

L<Mail::Box>: a comprehensive suite of mail manipulating modules. This
include: message construction, mbox/mail folder manipulation
(including access to POP3 mail accounts), sending mails. Support for
MIME mails.

L<Mail::Cclient> also gives access to various mailbox formats
(including IMAP mail accounts). The module relies on an additional C
library.

=head1 Templating systems

A comparison of web centered templating systems can be found at
L<http://perl.apache.org/docs/tutorials/tmpl/comparison/comparison.html>.

=head2 Standalone templating systems

There are too many around there. Just to name some:

L<Template> (Template-Toolkit), a very popular and feature-rich
system. Good documentation, good support.

L<HTML::Template>, another popular system. Not so feature-rich like
Template-Toolkit. Focus on HTML.

L<Text::ScriptTemplate>, a asp/jsp-like system to embed perl in a
template. Small and useful.

=head2 Apache

L<Apache::ASP>, to be used in conjuction with L<mod_perl>.

EmbPerl (L<HTML::Embperl>). More than just templating XXX?

Mason (L<HTML::Mason>). More than just templating XXX?

L<Apache::ASP>: a framework with a jsp/asp-like templating system XXX
check.

=head1 Web Frameworks

L<Catalyst> --- The Elegant MVC Web Application Framework 

L<Maypole>. A MVC system for Apache or cgi-bin.

See also L<HTML::Mason> and maybe L<Apache::ASP>, which are more than just
templating systems (is this true XXX?).

=head1 Versioning control systems

L<VCS> and others. Look which one is the best nowadays XXX.

=head1 Hash tools

To get ordered hashes, use either L<Tie::IxHash>,
L<Tie::InsertOrderHash> or L<Tie::Hash::Indexed>.

=head1 Regexp tools

L<Regexp::Assemble>: combine multiple regexpes into one. XXX More
modules doing similar things.

=head1 Module installation

The classic module is L<CPAN>, which comes with core perl. Someday,
L<CPANPLUS> will be the successor of CPAN.pm some day (once it is
stable etc.). L<CPAN::Mini> is a module for creating a minimal mirror
of the CPAN repository.

=head1 Logic programming

A list can be found at
L<http://www.perlmonks.org/index.pl?node_id=424075>. A discussion at
L<http://www.mail-archive.com/sw-design@metaperl.com/msg00115.html>.

=head1 File type detection

L<MIME::Types>: the name may be misleading --- the module is just an
file extension - mime type mapping. The module is not looking at
file's magic. It is supposed to work just like the MIME type
recognition of Apache.

Look at L<File::MMagic>, L<File::MimeInfo::Magic> and L<File::Type>
XXX.

=head1 File system

=head2 Copying files

L<File::Copy> is in the core. There's no support for recursive copying
or file attribute preservation.

L<File::NCopy> is able to make recursive copies and preserve file
attributes.

L<File::Copy::Recursive> is an alternative module for copying files
recursively.

=head2 Walking a file hierarchy

L<File::Find> is in the core. 

L<File::Find::Rule> is different XXX. Many plugins.

=head1 IO

=head2 Reading/writing to a scalar

Since 5.8.0, this can be done with three-arg L<open|perlfunc/open> and
a scalar ref instead of a filename. For former perl versions, use
either L<IO::Scalar> or L<IO::Stringy> (XXX correct?).

=head1 PDF creation

L<PDF::Create> works. Best to use version 0.06 from sourceforge
(project perl-pdf).


L<PDF::API2> is big and complete. But its seems to be slower than
PDF::Create, at least for my needs.

There are some templating solutions (PDF::Reuse, PDF::Template). And
there's also (non-perl) pdflatex!

=head1 Building software

L<ExtUtils::MakeMaker> is the old-fashioned standard way of building
perl modules and applications. Unfortunately it depends on the
existance of a C<make> tool on the system, so there's now a pure-perl
solution in the beginnings: L<Module::Build>.

A C<make> replacement as a perl module: L<Make>, together with a
command line tool C<pmake>.

L<Commands::Guarded> is an interesting module for guarded execution of
commands (better description!).

L<PANT> is meant as an C<ant> replacement to help to automate a build
environment. It is usually used as a meta script which calls external
C<make> commands and has some built-ins like NewerFile, CopyFile etc.

L<Cons> is a make replacement. Cons files are written in pure perl.

=head1 Parsers

See
L<http://sourceforge.net/docman/display_doc.php?docid=27420&group_id=133629>
about a comparison between L<Parse::RecDescent>, L<Parse::Yapp>, and
Perl-byacc.

=head1 CRC

L<String::CRC32>: fast, written in C.

L<Digest::Crc32>: very slow, written in pure perl.

There are also L<Digest::CRC> and L<String::CRC>.

=head1 Password generators

There are L<String::Random> and L<String::MkPasswd>.

=head1 Stripping accents

L<Text::Unidecode>: highly recommended, handles all Unicode
characters. There are also L<Text::Unaccent> and
L<Text::StripAccents>.

=head1 Logging

A good comparison can be found at:
L<http://search.cpan.org/dist/Log-Dispatch/lib/Log/Dispatch.pm#RELATED_MODULES>.

=head1 Sorting

L<Sort::Key> is (according to the author) the fastest way to sort an
array by key.

=head1 Class support

=head2 Autogenerating accessors

L<Class::Struct>: in the perl core, has a strange syntax and I
remember other issues (no backward compatibility).

L<Class::Accessor>: stable. Has varians for fast access
L<Class::Accessor::Fast> and lvalue access L<Class::Accessor::Lvalue>.

L<accessors>: simple syntax, has also some variants. Test suite spits
a lot of warnings.

L<Class::AccessorMaker>: ???

=head1 System administration

L<Sysadm::Install>: a box full of tools typical for automated
installation tasks. Looks very nice.

L<Commands::Guarded>: this is more a paradigma the a toolbox: every
action has a should-condition and an action. So it's possible to
restart a script after a previous failure and determining errors is
not done by checking error coded, but by checking the
should-condition.

=head1 Date and time modules

A classic one is L<Date::Calc>, a rather complete implementation of
date/time functions with a functional (somewhat non-perlish naming)
und object-oriented interfaces. It's written in C, so there's also a
pure perl replacement L<Date::Pcalc>.

The standard perl functions and modules: time, localtime, strftime and
mktime in L<POSIX>, L<Time::Local>.

Other efforts are: L<DateTime>, L<Time::Piece>, L<Date::Handler>,
L<Date::Manip>, ... (XXX check and compare all of these...)

=head1 Geo modules

L<Geo::Coder::US> is an interface to the free US geo data.

